<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 工具使用小Tips记录 · Gong</title><meta name="description" content="工具使用小Tips记录 - Bojie Gong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://gongbojie.com/atom.xml" title="Gong"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/p/1005052282743972" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/gongbojie" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">工具使用小Tips记录</h1><div class="post-info">Mar 7, 2019</div><div class="post-content"><h1 id="Markdowm"><a href="#Markdowm" class="headerlink" title="Markdowm"></a>Markdowm</h1><ol>
<li>markdown导出pdf时候强制换页，插入以下代码</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div STYLE="page-break-after: always;"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>手动触发tabbar的item</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// You can set the default index of the TabBarController by setting the selectedIndex property. This can be put in viewDidLoad or Before pushing the controller if you are doing it that way. This is done only when you are using a TabBarController and Not just a TabBar.</span><br><span class="line">tabBarController.selectedIndex = 1;</span><br><span class="line">// If you are using a TabBar without a TabBarController then you have to do it like this.</span><br><span class="line">self.tabBar.selectedItem = [self.tabBar.items objectAtIndex:1];</span><br></pre></td></tr></table></figure>
<h1 id="iOS相关"><a href="#iOS相关" class="headerlink" title="iOS相关"></a>iOS相关</h1><h2 id="1-iOS-AFN网络请求失败401时，如何获取后台返回的内容"><a href="#1-iOS-AFN网络请求失败401时，如何获取后台返回的内容" class="headerlink" title="1. iOS AFN网络请求失败401时，如何获取后台返回的内容"></a>1. iOS AFN网络请求失败401时，如何获取后台返回的内容</h2><p>开发中，会遇到当接口非200时，也需要去取后台返回的数据，以便客户端提示用。那怎拿到呢？就是在failure的回调里，加上下面代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSData *errorData = [error.userInfo objectForKey:AFNetworkingOperationFailingURLResponseDataErrorKey];</span><br><span class="line"></span><br><span class="line">NSString *responseString  = [[NSString alloc] initWithData:errorData encoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure>
<p>responseString字符串格式就是接口返回的内容。还可以转成字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:errorData options:NSJSONReadingAllowFragments error:nil];</span><br></pre></td></tr></table></figure>
<h2 id="2-实现TableViewCell的单选"><a href="#2-实现TableViewCell的单选" class="headerlink" title="2. 实现TableViewCell的单选"></a>2. 实现TableViewCell的单选</h2><p>利用cell的<code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated</code>方法</p>
<p>优点：不用任何外在属性，不用变量，不用数组。实现cell、或cell中Button的单选。并且不会因为复用而造成位置错乱。</p>
<p>实现方式：</p>
<ol>
<li>如果要有默认选择在初始化tableView完成后写</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0];</span><br><span class="line">[self.tableView selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone];</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后在cell中实现- (void)setSelected:(BOOL)selected animated:(BOOL)animated方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123;</span><br><span class="line">    [super setSelected:selected animated:animated];</span><br><span class="line">    if (selected) &#123;</span><br><span class="line">        self.selBtn.selected = YES;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        self.selBtn.selected = NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>didSelectRowAtIndexPath</code>方法中给点击的cell手动选中，并不需要刷新表格</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tableView selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone];</span><br></pre></td></tr></table></figure>
<h2 id="3-实现cell多选"><a href="#3-实现cell多选" class="headerlink" title="3. 实现cell多选"></a>3. 实现cell多选</h2><ul>
<li>把tableView的allowsMultipleSelection 属性设为了YES；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tableView.allowsMultipleSelection = YES;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 didSelectRowAtIndexPath 和 didDeselectRowAtIndexPath 方法里面使用了如下方法实现了点击单元格然后用check mark 标记的方式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">		</span><br><span class="line">      UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    	</span><br><span class="line">	  cell.accessoryType = UITableViewCellAccessoryCheckmark;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">-(void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">	[tableView cellForRowAtIndexPath:indexPath].accessoryType = UITableViewCellAccessoryNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>防止复用的思路</p>
<ol>
<li>记录选择的indexpath</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1.设一个NSMutableArray属性，元素个数跟你的_dataArray一样，初始化里面存的都是0。</span><br><span class="line"> 	</span><br><span class="line">	 NSMutableArray* selectionArray = [NSMutableArray array];</span><br><span class="line">	 for (NSInteger i = 0; i &lt; _dataArray.count; i++) &#123;</span><br><span class="line">    	[selectionArray addObject:@(0)]; // 0 表示未选中，1 表示选中了</span><br><span class="line">	 &#125;</span><br><span class="line">	 self.selectionArray = selectionArray; </span><br><span class="line">	 </span><br><span class="line">   // 2.在 didSelectRowAtIndexPath:里</span><br><span class="line">   </span><br><span class="line">	 [self.selectionArray replaceObjectAtIndex:indexPath.row withObject:@(1)];</span><br><span class="line">	</span><br><span class="line">	 [self.tableView reloadData];</span><br><span class="line"></span><br><span class="line">   // 3.在 didDeselectRowAtIndexPath里：</span><br><span class="line">   </span><br><span class="line">	 [self.selectionArray replaceObjectAtIndex:indexPath.row withObject:@(0)];</span><br><span class="line">	</span><br><span class="line">	 [self.tableView reloadData];</span><br><span class="line"></span><br><span class="line">   // 4.在 cellForRow里：</span><br><span class="line">	UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];</span><br><span class="line">	cell.textLabel.text = _dataArray[indexPath.row];</span><br><span class="line">	NSInteger selected = [self.selectionArray[indexPath.row] IntegerValue];</span><br><span class="line">	if (selected == 0) &#123;</span><br><span class="line">    cell.accessoryType = UITableViewCellAccessoryNone;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">    	cell.accessoryType = UITableViewCellAccessoryCheckmark;</span><br><span class="line">	&#125;</span><br><span class="line">	return cell;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>利用cell的selected属性</li>
</ol>
<ul>
<li>继承UITableViewCell，在setSeleted:animated:方法里面，根据选择状态，修改accessoryType</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123;</span><br><span class="line">    [super setSelected:selected animated:animated];</span><br><span class="line">    self.accessoryType = selected?UITableViewCellAccessoryCheckmark:UITableViewCellAccessoryNone;</span><br><span class="line">    // Configure the view for the selected state</span><br><span class="line">&#125;</span><br><span class="line">	 </span><br><span class="line">	// 在 cellForRow里：</span><br><span class="line">	cell.accessoryType = cell.selected?UITableViewCellAccessoryCheckmark:UITableViewCellAccessoryNone;</span><br></pre></td></tr></table></figure>
<p>解决因为复用所导致的问题</p>
<p>tableView的一些设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 设置tableView可不可以选中</span><br><span class="line">self.tableView.allowsSelection = NO;</span><br><span class="line"></span><br><span class="line">// 允许tableview多选</span><br><span class="line">self.tableView.allowsMultipleSelection = YES;</span><br><span class="line"></span><br><span class="line">// 编辑模式下是否可以选中</span><br><span class="line">self.tableView.allowsSelectionDuringEditing = NO;</span><br><span class="line"></span><br><span class="line">// 编辑模式下是否可以多选</span><br><span class="line">self.tableView.allowsMultipleSelectionDuringEditing = YES;</span><br><span class="line"></span><br><span class="line">// 获取被选中的所有行</span><br><span class="line">[self.tableView indexPathsForSelectedRows]</span><br><span class="line"></span><br><span class="line">// 获取当前可见的行</span><br><span class="line">[self.tableView indexPathsForVisibleRows];</span><br></pre></td></tr></table></figure>
<h2 id="4-属性修饰词"><a href="#4-属性修饰词" class="headerlink" title="4. 属性修饰词"></a>4. 属性修饰词</h2><p>当修饰可变类型的属性时，如<code>NSMutableArray</code>、<code>NSMutableDictionary</code>、<code>NSMutableString</code>，用<code>strong</code>。</p>
<p>当修饰不可变类型的属性时，如<code>NSArray</code>、<code>NSDictionary</code>、<code>NSString</code>，用<code>copy</code>。</p>
<h2 id="5-iOS返回到指定页面的方法"><a href="#5-iOS返回到指定页面的方法" class="headerlink" title="5. iOS返回到指定页面的方法"></a>5. iOS返回到指定页面的方法</h2><ol>
<li>返回到指定页面 但不是根界面的某个页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UserViewController *homeVC = [[UserViewController alloc] init];</span><br><span class="line">UIViewController *target = nil;</span><br><span class="line">for (UIViewController * controller in self.navigationController.viewControllers) &#123; </span><br><span class="line">  if ([controller isKindOfClass:[homeVC class]]) &#123; </span><br><span class="line">    target = controller;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target) &#123;</span><br><span class="line">  [self.navigationController popToViewController:target animated:YES]; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>返回根页面的某个页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController.tabBarController.hidesBottomBarWhenPushed=NO;</span><br><span class="line">self.navigationController.tabBarController.selectedIndex=0;</span><br><span class="line">[self.navigationController popToRootViewControllerAnimated:YES];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>返回上两级页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (self.navigationController.viewControllers.count &gt;= 2) &#123;</span><br><span class="line">  UIViewController *vc = [self.navigationController.viewControllers  objectOrNilAtIndex:1];</span><br><span class="line">  [self.navigationController popToViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><p>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)</p>
<p>沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)</p>
<p>沙盒中常用的几个路径:<br>Document文件夹：<br>用来保存应由程序运行时生成的需要持久化的数据， iTunes会自动备份该目录（苹果公司建议将程序中创建的和浏览过的程序存放在这里，iTunes在备份和回复时会自动包含此目录）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//文件路径是数组，这里取第一个元素</span><br><span class="line">NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];</span><br></pre></td></tr></table></figure>
<p>Library文件夹：<br>用来存储程序的默认设置和其他状态信息，iTunes也会自动备份该目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *libraryPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)[0];</span><br></pre></td></tr></table></figure>
<p>Library/Caches:<br>用来存放缓存文件，iTunes不会备份此目录，此目录下的文件不会在程序退出后删除，一般存放体积比较大但又不太重要的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</span><br></pre></td></tr></table></figure>
<p>Library/Preferences:<br>用来存储用户的偏好设置，iOS的setting（设置）会在这个目录中查找应用程序的设置信息，iTunes会自动备份该目录，通常这个文件夹都是由系统进行维护的，建议不要操作他。<br>系统没有直接获取这个文件夹路径的方法,需要先获取Library路径然后进行字符串拼接找到此路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *libraryPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDoMainMask, YES)[0]; </span><br><span class="line">NSString*preferencePath = [libraryPath stringByAppendingString:@&quot;/Preferences&quot;];</span><br></pre></td></tr></table></figure>
<p>注意：不要直接写偏好设置到这个文件夹，而是通过NSUserDefaults来进行偏好设置的保存和读取。</p>
<p>tmp：<br>保存应用程序的临时文件夹，使用完毕后，将相应的文件从这个目录中删除，如果空间不够，系统也可能会删除这个目录下的文件，iTunes不会同步这个文件夹，在iPhone重启的时候，该目录下的文件会被删除。<br>这个路径的获取方法和其他的不同,它有自己方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *tmpPath = NSTemporaryDirectory();</span><br></pre></td></tr></table></figure>
<p>模拟器沙盒查看 <code>(lldb) po NSHomeDirectory()</code></p>
<p>清理<code>/Library/Caches</code>目录文件,理论上来讲是没错，所有的缓存文件都会放在app沙盒目录的Caches文件目录下，<strong><em>这样的清理模拟器能通过，真机则会因为没有Snapshot的访问权限而中止清理。</em></strong></p>
<p>所以实际应用中我们的计算缓存大小函数，以及清理函数需要跳过Snapshot这个文件目录，不讲目录文件大小计入缓存大小，清理的时候跳过该目录防止中断。</p>
<p><code>clearCacheTool.m</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark - 获取Cache文件夹大小</span><br><span class="line">+ (NSString *)getCacheSize &#123;</span><br><span class="line">    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">    NSString *totleSize = [ClearCachesTool getCacheSizeWithFilePath:cachesPath];</span><br><span class="line">    return totleSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 删除Cache文件夹中的缓存</span><br><span class="line">+ (BOOL)clearCache &#123;</span><br><span class="line">    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">    BOOL isAlreadyClearCache = [ClearCachesTool clearCacheWithFilePath:cachesPath];</span><br><span class="line">    return isAlreadyClearCache;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)readyClearCache &#123;</span><br><span class="line">    BOOL isClearCache = [ClearCachesTool clearCache];</span><br><span class="line">    if (isClearCache) &#123;</span><br><span class="line">        NSLog(@&quot;清理完毕&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;清理失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 获取path路径下文件夹大小</span><br><span class="line">+ (NSString *)getCacheSizeWithFilePath:(NSString *)path &#123;</span><br><span class="line"></span><br><span class="line">    // 获取“path”文件夹下的所有文件</span><br><span class="line">    NSArray *subPathArr = [[NSFileManager defaultManager] subpathsAtPath:path];</span><br><span class="line">    NSString *filePath  = nil;</span><br><span class="line">    NSInteger totleSize = 0;</span><br><span class="line">    for (NSString *subPath in subPathArr)&#123;</span><br><span class="line">//        NSLog(@&quot;getCacheSize = %@&quot;,subPath);</span><br><span class="line">        // 0. 把Snapshots文件夹过滤掉,没有访问权限,否则删除时操过200M会失败!!!!!!!!</span><br><span class="line">        if (![subPath containsString:@&quot;Snapshots&quot;]) &#123;</span><br><span class="line">            // 1. 拼接每一个文件的全路径</span><br><span class="line">            filePath =[path stringByAppendingPathComponent:subPath];</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 是否是文件夹，默认不是</span><br><span class="line">        BOOL isDirectory = NO;</span><br><span class="line">        // 3. 判断文件是否存在</span><br><span class="line">        BOOL isExist = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&amp;isDirectory];</span><br><span class="line">        // 4. 以上判断目的是忽略不需要计算的文件</span><br><span class="line">        if (!isExist || isDirectory || [filePath containsString:@&quot;.DS&quot;])&#123;</span><br><span class="line">            // 过滤: 1. 文件夹不存在  2. 过滤文件夹  3. 隐藏文件</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5. 指定路径，获取这个路径的属性</span><br><span class="line">        NSDictionary *dict = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">        /**</span><br><span class="line">         attributesOfItemAtPath: 文件夹路径</span><br><span class="line">         该方法只能获取文件的属性, 无法获取文件夹属性, 所以也是需要遍历文件夹的每一个文件的原因</span><br><span class="line">         */</span><br><span class="line">        // 6. 获取每一个文件的大小</span><br><span class="line">        NSInteger size = [dict[@&quot;NSFileSize&quot;] integerValue];</span><br><span class="line">        // 7. 计算总大小</span><br><span class="line">        totleSize += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8. 将文件夹大小转换为 M/KB/B</span><br><span class="line">    NSString *totleStr = nil;</span><br><span class="line">    if (totleSize &gt; 1000 * 1000)&#123;</span><br><span class="line">        totleStr = [NSString stringWithFormat:@&quot;%.2fM&quot;,totleSize / 1000.00f /1000.00f];</span><br><span class="line">    &#125;else if (totleSize &gt; 1000)&#123;</span><br><span class="line">        totleStr = [NSString stringWithFormat:@&quot;%.2fKB&quot;,totleSize / 1000.00f ];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        totleStr = [NSString stringWithFormat:@&quot;%.2fB&quot;,totleSize / 1.00f];</span><br><span class="line">    &#125;</span><br><span class="line">    return totleStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 清除path文件夹下缓存大小--/Caches/Snapshots,真机测试会输出error</span><br><span class="line">//Error Domain=NSCocoaErrorDomain Code=513 &quot;未能移除“Snapshots”，因为您没有访问它的权限。&quot;</span><br><span class="line">+ (BOOL)clearCacheWithFilePath:(NSString *)path&#123;</span><br><span class="line"></span><br><span class="line">    //拿到path路径的下一级目录的子文件夹</span><br><span class="line">    NSArray *subPathArr = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:nil];</span><br><span class="line">    NSString *filePath = nil;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    for (NSString *subPath in subPathArr) &#123;</span><br><span class="line">        filePath = [path stringByAppendingPathComponent:subPath];</span><br><span class="line">//        NSLog(@&quot;%@&quot;,filePath);</span><br><span class="line">        if (![filePath containsString:@&quot;/Caches/Snapshots&quot;]) &#123;</span><br><span class="line">            //删除子文件夹</span><br><span class="line">            [[NSFileManager defaultManager] removeItemAtPath:filePath error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;,error);</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  caches文件夹下缓存大小</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString *cachesSize;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self getCachesSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 获取Caches文件夹缓存大小</span><br><span class="line">- (void)getCachesSize &#123;</span><br><span class="line">    // 子线程计算文件缓存</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">        NSString *cachesSize = [ClearCachesTool getCacheSize];</span><br><span class="line">        self.cachesSize = cachesSize;</span><br><span class="line">        // 主线程更新显示</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           // cell.detailTextLabel.text = cachesSize;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 删除Caches文件夹缓存</span><br><span class="line">- (void)clearCaches &#123;</span><br><span class="line">    // 子线程做删除耗时操作</span><br><span class="line">    if (self.cachesSize == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *message = [NSString stringWithFormat:@&quot;缓存大小为%@,确定要清理吗?&quot;,self.cachesSize];</span><br><span class="line"></span><br><span class="line">    UIAlertController *alertC = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:message preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil];</span><br><span class="line">    UIAlertAction *certain = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        [SVProgressHUD showWithStatus:@&quot;正在拼命清理中...&quot;];</span><br><span class="line"></span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            [ClearCachesTool clearCache];</span><br><span class="line">            // 主线程刷新显示</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [SVProgressHUD dismiss];</span><br><span class="line">                self.cachesSize = nil;</span><br><span class="line">                cell.detailTextLabel.text = @&quot;清理完毕&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [alertC addAction:cancel];</span><br><span class="line">    [alertC addAction:certain];</span><br><span class="line">    [self presentViewController:alertC animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 点击按钮触发是否更新提示</span><br><span class="line">- (void)clearClick &#123;</span><br><span class="line">    [self clearCaches];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在程序的启动时强制更改程序语言设置"><a href="#在程序的启动时强制更改程序语言设置" class="headerlink" title="在程序的启动时强制更改程序语言设置"></a>在程序的启动时强制更改程序语言设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">     //do something</span><br><span class="line">    //强制设置语言为简体中文</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:@&quot;zh-hans&quot;,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 保存 Device 的现语言 (英语 法语 ，，，)</span><br><span class="line">NSMutableArray *userDefaultLanguages = [[NSUserDefaults standardUserDefaults]</span><br><span class="line">                                        objectForKey:@&quot;AppleLanguages&quot;];</span><br><span class="line"></span><br><span class="line">// 强制 成 简体中文</span><br><span class="line">[[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:@&quot;zh-hans&quot;,nil]</span><br><span class="line">                                              forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">//接下来就是你想要的中文了</span><br><span class="line"></span><br><span class="line">//用完了，转回来， 还原Device 的语言</span><br><span class="line"> [[NSUserDefaults standardUserDefaults] setObject:userDefaultLanguages forKey:@&quot;AppleLanguages&quot;];</span><br></pre></td></tr></table></figure>
<h1 id="XCode相关"><a href="#XCode相关" class="headerlink" title="XCode相关"></a>XCode相关</h1><ol>
<li><p>错误描述：</p>
<p> 虽然勾选了自动管理证书和描述文件，但实际上描述文件被指定为XXXXXX，导致冲突。</p>
<p> Code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 11.2’<br>这个应该是因为第一个错误产生的，可以不管，把第一个错误fix即可。</p>
<p> 解决办法：</p>
<p> 打开项目的project.pbxproj文件，全局搜索XXXXXX，把指定行删除然后保存即可。</p>
</li>
<li><p>错误描述：</p>
<p> <code>Undefined symbols for architecture armv7:</code></p>
<p> 解决办法：</p>
<p> 没有满足所有的架构 不支持4S手机<br> 找到  Build Settings 输入 Valid Architectures   删掉armv7  OK。问题解决。</p>
<blockquote>
<p>armv7｜armv7s｜arm64都是ARM处理器的指令集<br> armv7｜armv7s｜arm64都是ARM处理器的指令集<br> i386｜x86_64 是Mac处理器的指令集</p>
</blockquote>
<blockquote>
<p>arm64：iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S | iPad Air｜ iPad mini2(iPad mini with Retina Display)</p>
</blockquote>
<blockquote>
<p>armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p>
</blockquote>
<blockquote>
<p>armv7：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p>
</blockquote>
<blockquote>
<p>i386是针对intel通用微处理器32位处理器</p>
</blockquote>
<blockquote>
<p>x86_64是针对x86架构的64位处理器</p>
</blockquote>
<blockquote>
<p>模拟器32位处理器测试需要i386架构，</p>
</blockquote>
<blockquote>
<p>模拟器64位处理器测试需要x86_64架构，</p>
</blockquote>
<blockquote>
<p>真机32位处理器需要armv7,或者armv7s架构，</p>
</blockquote>
<blockquote>
<p>真机64位处理器需要arm64架构。</p>
</blockquote>
<blockquote>
<p>Xcode中指令集相关选项（Build Setting中）</p>
</blockquote>
</li>
</ol>
<p>Architectures</p>
<p>指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p>
<p>Valid Architectures</p>
<p>限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定</p>
<p>Build Active Architecture Only</p>
<p>指定是否只对当前连接设备所支持的指令集编译</p>
<p>当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/06/06/隐私政策/" class="prev">PREV</a><a href="/2019/01/25/Xcode打包上传AppStore问题/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://gongbojie.com">Bojie Gong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>