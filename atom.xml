<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gong</title>
  
  <subtitle>完成比完美更重要。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gongbojie.com/"/>
  <updated>2021-03-20T04:39:29.580Z</updated>
  <id>https://gongbojie.com/</id>
  
  <author>
    <name>Bojie Gong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于UITableViewCell分割线的去除和自定义删除按钮</title>
    <link href="https://gongbojie.com/2021/03/20/%E5%85%B3%E4%BA%8EUITableViewCell%E5%88%86%E5%89%B2%E7%BA%BF%E7%9A%84%E5%8E%BB%E9%99%A4/"/>
    <id>https://gongbojie.com/2021/03/20/关于UITableViewCell分割线的去除/</id>
    <published>2021-03-20T04:02:09.000Z</published>
    <updated>2021-03-20T04:39:29.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义左滑删除键"><a href="#自定义左滑删除键" class="headerlink" title="自定义左滑删除键"></a>自定义左滑删除键</h2><p>在iOS 12和iOS 13、iOS 14下，cell左滑删除键属于不同层级。<br>如果需要对其进行自定义，就需要进行不同的操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willBeginEditingRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    NewsCenterModel *model = <span class="keyword">self</span>.viewModel.tableViewData[indexPath.row];</span><br><span class="line">    <span class="built_in">CGFloat</span> cellHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (model.msgValue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cellHeight = [HrssMsgCenterCell setCellHeightWithModel:model] - <span class="number">8</span> - <span class="number">7</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cellHeight = [HrssMsgCenterCell setCellHeightWithModel:model] - <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> tableView.subviews) &#123;</span><br><span class="line">        <span class="comment">// iOS 12</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([subview <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UISwipeActionPullView"</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([subview.subviews[<span class="number">0</span>] <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UISwipeActionStandardButton"</span>]) &#123;</span><br><span class="line">                <span class="built_in">CGRect</span> newFrame = subview.subviews[<span class="number">0</span>].frame;</span><br><span class="line">                newFrame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">8</span>, newFrame.size.width, cellHeight);</span><br><span class="line">                subview.subviews[<span class="number">0</span>].frame = newFrame;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Other changes on this view can also be applied like</span></span><br><span class="line">                subview.backgroundColor = [<span class="built_in">UIColor</span> groupTableViewBackgroundColor];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// iOS 13/iOS 14</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([subview <span class="keyword">class</span>]) isEqualToString:<span class="string">@"_UITableViewCellSwipeContainerView"</span>]) &#123;</span><br><span class="line">            <span class="built_in">UIView</span> *swipeActionPullView = subview.subviews[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([swipeActionPullView <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UISwipeActionPullView"</span>]) &#123;</span><br><span class="line">                <span class="built_in">UIView</span> *swipeActionStandardButton = swipeActionPullView.subviews[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([swipeActionStandardButton <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UISwipeActionStandardButton"</span>]) &#123;</span><br><span class="line">                    <span class="built_in">CGRect</span> newFrame = swipeActionStandardButton.frame;</span><br><span class="line">                    newFrame = <span class="built_in">CGRectMake</span>(kSCREEN_WIDTH - newFrame.size.width, <span class="number">8</span>, newFrame.size.width, cellHeight);</span><br><span class="line">                    swipeActionStandardButton.frame = newFrame;</span><br><span class="line">                    swipeActionPullView.frame = newFrame;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//Other changes on this view can also be applied like</span></span><br><span class="line">                    swipeActionPullView.backgroundColor = [<span class="built_in">UIColor</span> groupTableViewBackgroundColor];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="1.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">iOS 13/iOS 14</div><br></center><br><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="3.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">iOS 13/iOS 14</div><br></center><br><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="2.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">iOS 12</div><br></center><br><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="4.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">iOS 12</div><br></center><h2 id="删除cell的分割线"><a href="#删除cell的分割线" class="headerlink" title="删除cell的分割线"></a>删除cell的分割线</h2><p>在cell.m中加上这一个方法即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addSubview:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![view isKindOfClass:[<span class="built_in">NSClassFromString</span>(<span class="string">@"_UITableViewCellSeparatorView"</span>) <span class="keyword">class</span>]] &amp;&amp; view)</span><br><span class="line">          [<span class="keyword">super</span> addSubview:view];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自定义左滑删除键&quot;&gt;&lt;a href=&quot;#自定义左滑删除键&quot; class=&quot;headerlink&quot; title=&quot;自定义左滑删除键&quot;&gt;&lt;/a&gt;自定义左滑删除键&lt;/h2&gt;&lt;p&gt;在iOS 12和iOS 13、iOS 14下，cell左滑删除键属于不同层级。&lt;br&gt;如果需
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Masonry中的比例设置</title>
    <link href="https://gongbojie.com/2020/10/12/Masonry%E4%B8%AD%E7%9A%84%E6%AF%94%E4%BE%8B%E8%AE%BE%E7%BD%AE/"/>
    <id>https://gongbojie.com/2020/10/12/Masonry中的比例设置/</id>
    <published>2020-10-12T07:05:04.000Z</published>
    <updated>2020-10-12T07:52:09.181Z</updated>
    
    <content type="html"><![CDATA[<p>Masonry中设置比例的属性有multipliedBy与dividedBy</p><p>区别：</p><p>multipliedBy是相对于自身比例（只能用于自身的比）dividedBy是相对于其他视图的比例（也可以用于自身的比），multipliedBy是相当于算数中的“除以”，dividedBy相当于算数中的“除”。</p><ul><li>multipliedBy相对于自身比</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UIView *view1 = [[UIView alloc] init];</span><br><span class="line">view1.backgroundColor = [UIColor redColor];</span><br><span class="line">[self.view addSubview:view1];</span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.width.mas_offset(100);</span><br><span class="line">    make.top.mas_equalTo(self.view.mas_top).mas_offset(100 + kStatusBarAndNaviBarH);</span><br><span class="line">    make.width.mas_equalTo(view1.mas_height).multipliedBy(0.3);</span><br><span class="line">    make.centerX.mas_equalTo(self.view.mas_centerX);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>dividedBy相对于其他视图的比例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UIView *view2 = [[UIView alloc] init];</span><br><span class="line">view2.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:view2];</span><br><span class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view1.mas_bottom).mas_offset(100);</span><br><span class="line">    make.centerX.mas_equalTo(self.view.mas_centerX);</span><br><span class="line">    make.width.mas_equalTo(view1.mas_width);</span><br><span class="line">    make.height.mas_equalTo(view1.mas_height).dividedBy(2);</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>dividedBy绿色线距self.view的1/5处，lineV.left除self.view.mas_right=5,相当于把self.view.withd划分五份</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIView *lineV = [[UIView alloc] init];</span><br><span class="line">lineV.backgroundColor = [UIColor greenColor];</span><br><span class="line">[self.view addSubview:lineV];</span><br><span class="line"></span><br><span class="line">[lineV mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.height.mas_equalTo(self.view.mas_height);</span><br><span class="line">    make.top.mas_equalTo(self.view.mas_top);</span><br><span class="line">    make.width.mas_offset(1);</span><br><span class="line">    make.left.mas_equalTo(self.view.mas_right).dividedBy(5);</span><br><span class="line">   </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>multipliedBy红色线处于self.view的中间位置，linev2.left除以self.view.mas_right = 0.5</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UIView *linev2 = [[UIView alloc] init];</span><br><span class="line">linev2.backgroundColor = [UIColor redColor];</span><br><span class="line">[self.view addSubview:linev2];</span><br><span class="line"></span><br><span class="line">[linev2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.view.mas_top);</span><br><span class="line">    make.height.mas_equalTo(self.view.mas_height);</span><br><span class="line">    make.width.mas_offset(1);</span><br><span class="line">    make.left.mas_equalTo(self.view.mas_right).multipliedBy(0.5);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>dividedBy用于自身视图的比</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UIView *lineV3 = [[UIView alloc] init];</span><br><span class="line">lineV3.backgroundColor = [UIColor greenColor];</span><br><span class="line">[self.view addSubview:lineV3];</span><br><span class="line"></span><br><span class="line">[lineV3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(self.view.mas_top).offset(kStatusBarAndNaviBarH);</span><br><span class="line">    make.width.mas_offset(100);</span><br><span class="line">    make.centerX.mas_equalTo(self.view.mas_centerX);</span><br><span class="line">    make.height.mas_equalTo(lineV3.mas_width).dividedBy(2);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Masonry中设置比例的属性有multipliedBy与dividedBy&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;multipliedBy是相对于自身比例（只能用于自身的比）dividedBy是相对于其他视图的比例（也可以用于自身的比），multipliedBy是相当于算数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App内webview跳转支付宝</title>
    <link href="https://gongbojie.com/2020/09/29/App%E5%86%85webview%E8%B7%B3%E8%BD%AC%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    <id>https://gongbojie.com/2020/09/29/App内webview跳转支付宝/</id>
    <published>2020-09-29T12:00:32.000Z</published>
    <updated>2020-09-30T08:31:49.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="App内的webview跳转支付宝的步骤以及遇到的问题"><a href="#App内的webview跳转支付宝的步骤以及遇到的问题" class="headerlink" title="App内的webview跳转支付宝的步骤以及遇到的问题"></a>App内的webview跳转支付宝的步骤以及遇到的问题</h1><ol><li>在Info.plist的LSApplicationQueriesSchemes中添加alipays、alipay,否则报错：This app is not allowed to query for scheme<br><img src="IMG_01.png" width="100%" height="100%"></li><li>在TARGET-Info-URL Types中请勿填写alipay与alipays，否则无法跳转到支付宝，该处时填写本app的唯一标识符<br><img src="IMG_02.png" width="100%" height="100%"></li><li>在TARGET-Info-URL Types中填写该应用的bundle id，并且填写可以跳转该app的url，例如<code>gdhrss://</code>即可跳转<br><img src="IMG_03.png" width="100%" height="100%"></li></ol><h1 id="期间遇到的问题"><a href="#期间遇到的问题" class="headerlink" title="期间遇到的问题"></a>期间遇到的问题</h1><h2 id="1-URLWithString返回为空nil"><a href="#1-URLWithString返回为空nil" class="headerlink" title="1. URLWithString返回为空nil"></a>1. URLWithString返回为空nil</h2><p>解决办法把url字符串进行UTF-8编码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9之后已废弃</span></span><br><span class="line">[urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换为</span></span><br><span class="line">[urlString stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"`#%^&#123;&#125;\"[]|\\&lt;&gt; "</span>]];</span><br></pre></td></tr></table></figure><p><a href="https://robberjj.github.io/2017/07/22/Encode_Update/" target="_blank" rel="noopener">参考文章</a></p><h2 id="2-获取当前控制器ViewController"><a href="#2-获取当前控制器ViewController" class="headerlink" title="2. 获取当前控制器ViewController"></a>2. 获取当前控制器ViewController</h2><ol><li>用tabBarController的时候</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前的VC</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)getNowViewController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *reController = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//当前用的tabBarController</span></span><br><span class="line">    <span class="keyword">if</span> (_tabBarController!=<span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UINavigationController</span>  *nav = (<span class="built_in">UINavigationController</span> *)[[_tabBarController viewControllers] objectAtIndex:_tabBarController.selectedIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIViewController</span> *topController = [nav topViewController];</span><br><span class="line">        <span class="keyword">id</span> tempViewController = topController;</span><br><span class="line">        <span class="keyword">while</span> ([(<span class="built_in">UIViewController</span> *)tempViewController  presentedViewController]!=<span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempViewController = [(<span class="built_in">UIViewController</span> *)tempViewController  presentedViewController];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempViewController!=<span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ([tempViewController isKindOfClass:[<span class="built_in">UINavigationController</span> <span class="keyword">class</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                reController = [(<span class="built_in">UINavigationController</span> *)tempViewController topViewController];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                reController = tempViewController;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            reController = topController;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//NSLog(@"getNowViewController is %@....",[reController class]);</span></span><br><span class="line">    <span class="keyword">return</span> reController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、平常的用法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 获取当前控制器</span></span><br><span class="line">-(<span class="built_in">UIViewController</span> *)getCurrentController&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewController</span> *reController = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">UIWindow</span> *window = [[<span class="built_in">UIApplication</span> sharedApplication]keyWindow];</span><br><span class="line">    <span class="keyword">if</span> (window.windowLevel!= <span class="built_in">UIWindowLevelNormal</span>) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = [[<span class="built_in">UIApplication</span> sharedApplication]windows];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIWindow</span> *win <span class="keyword">in</span> array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (win.windowLevel == <span class="built_in">UIWindowLevelNormal</span>) &#123;</span><br><span class="line">                window = win;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIView</span> *cuView = [[window subviews]objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">id</span> responder = [cuView nextResponder];</span><br><span class="line">    <span class="keyword">if</span> ([responder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        reController = responder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        reController = window.rootViewController;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/b3dd0082f2d2" target="_blank" rel="noopener">参考文章</a></p><h2 id="3-截取URL中的参数"><a href="#3-截取URL中的参数" class="headerlink" title="3. 截取URL中的参数"></a>3. 截取URL中的参数</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLComponents</span> *urlComponents = [<span class="built_in">NSURLComponents</span> componentsWithURL:decodeUrl resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// url中参数的key value</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *parameter = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *item <span class="keyword">in</span> urlComponents.queryItems) &#123;</span><br><span class="line">    [parameter setValue:item.value forKey:item.name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到parameter参数字典</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/f5ed2cc0313c" target="_blank" rel="noopener">swift版本</a></p><h2 id="4-NSURL"><a href="#4-NSURL" class="headerlink" title="4. NSURL"></a>4. <a href="https://www.jianshu.com/p/38f5f53dfbad" target="_blank" rel="noopener">NSURL</a></h2><p>一般格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</span><br></pre></td></tr></table></figure><p>具体接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               path</span><br><span class="line">        ┌───────────────┴───────────────┐┌───┴────┐</span><br><span class="line">  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port                  query         fragment</span><br><span class="line"></span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └────────────┬───────────────┘</span><br><span class="line">scheme            path</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;App内的webview跳转支付宝的步骤以及遇到的问题&quot;&gt;&lt;a href=&quot;#App内的webview跳转支付宝的步骤以及遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;App内的webview跳转支付宝的步骤以及遇到的问题&quot;&gt;&lt;/a&gt;App内的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>适配iOS14相关问题</title>
    <link href="https://gongbojie.com/2020/09/25/%E9%80%82%E9%85%8DiOS14%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://gongbojie.com/2020/09/25/适配iOS14相关问题/</id>
    <published>2020-09-25T02:54:51.000Z</published>
    <updated>2020-09-27T05:39:00.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-iOS14-UITableViewCell里添加子View不响应"><a href="#1-iOS14-UITableViewCell里添加子View不响应" class="headerlink" title="1. iOS14 UITableViewCell里添加子View不响应"></a>1. iOS14 UITableViewCell里添加子View不响应</h1><p>点击UITableViewCell的子控件无反应。通过查看页面层级，发现UITableViewCellContentView覆盖到了所有控件之上。</p><p><img src="IMG_01.png" width="80%" height="80%"></p><p>解决方案：<code>[cell addSubView:xx];</code>，修改为<code>[cell.contentView addSubView:xx];</code>。</p><p><img src="IMG_02.png" width="80%" height="80%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-iOS14-UITableViewCell里添加子View不响应&quot;&gt;&lt;a href=&quot;#1-iOS14-UITableViewCell里添加子View不响应&quot; class=&quot;headerlink&quot; title=&quot;1. iOS14 UITableViewCell
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIView相关问题</title>
    <link href="https://gongbojie.com/2020/09/17/UIView%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://gongbojie.com/2020/09/17/UIView相关问题/</id>
    <published>2020-09-17T01:51:36.000Z</published>
    <updated>2020-09-18T15:17:04.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义UITableView不展示，cellForRowAtIndexPath不执行的问题"><a href="#1-自定义UITableView不展示，cellForRowAtIndexPath不执行的问题" class="headerlink" title="1. 自定义UITableView不展示，cellForRowAtIndexPath不执行的问题"></a>1. 自定义UITableView不展示，cellForRowAtIndexPath不执行的问题</h2><p>依次检查以下情况：</p><ol><li>dataSource和delegate没有设置</li><li>numberOfRowsInSection和numberOfRowsInSection返回的数据不是大于0的整数</li><li>tableView没有添加到父视图上</li><li>高度为0 也会导致不执行</li><li>重写tableView的layoutSubview方法</li><li>layoutSubview没有执行</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ApplyProgressView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame style:(<span class="built_in">UITableViewStyle</span>)style &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame style:style];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">self</span>.dataSource = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">self</span>.tableFooterView = [<span class="built_in">UIView</span> new];</span><br><span class="line">        <span class="keyword">self</span>.separatorStyle = <span class="built_in">UITableViewCellSeparatorStyleNone</span>;</span><br><span class="line">        [<span class="keyword">self</span> layoutSubviews];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-UIScrollview-Masonry"><a href="#2-UIScrollview-Masonry" class="headerlink" title="2. UIScrollview+Masonry"></a>2. UIScrollview+Masonry</h2><p>给所有的subView加一个container，然后设置container的constraint：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make.edges.equalTo(scrollView);</span><br><span class="line">make.width.equalTo(scrollView);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"> [<span class="keyword">self</span>.scrollView addSubview:<span class="keyword">self</span>.containerView];</span><br><span class="line">    [<span class="keyword">self</span>.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.edges.equalTo(<span class="keyword">self</span>.scrollView);</span><br><span class="line">        make.height.equalTo(<span class="keyword">self</span>.scrollView);</span><br><span class="line">        make.width.equalTo(@(SCREEN_WIDTH * <span class="number">2</span>));</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>如果我们需要竖向的滑动 就把width设为和scrollview相同<br>如果需要横向的滑动 就把height设为和scrollview相同</p><p><a href="http://adad184.com/2015/12/01/scrollview-under-autolayout/" target="_blank" rel="noopener">参考文章</a></p><h2 id="3-UIView自定义之纯代码"><a href="#3-UIView自定义之纯代码" class="headerlink" title="3. UIView自定义之纯代码"></a>3. UIView自定义之纯代码</h2><p>一般步骤：</p><ol><li>重写<code>- (instancetype)initWithFrame:(CGRect)frame</code>方法中添加子控件,但是不设置子控件frame；</li><li>重写<code>- (void)layoutSubviews</code>中设置子控件frame注意必须调用<code>[super layoutSubviews]</code>;</li><li>提供模型属性，并重写该模型属性的set方法；</li><li>在该set方法中取出相应属性并给子控件赋值；</li></ol><p>使用纯代码创建自定义View,在之后使用的过程中，可能会使用<code>init</code>创建，也可能使用<code>initWithFrame</code>创建。无论使用哪种方式，在代码执行过程中最终一定会调用<code>initWithFrame</code>,所以重写<code>initWithFrame</code>方法可以保证无论使用哪种方式创建都可以保证子控件创建成功;</p><blockquote><p>为什么先打印的是<code>initWithFrame</code>而不是<code>init</code>?</p><p>注意看<code>- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;</code>其中的关键字<code>NS_DESIGNATED_INITIALIZER</code>作用当面对多个初始化方法时，不知道哪一个才是正确的初始化方法，对此，苹果提供了两个关键字：<code>NS_UNAVAILABLE</code>与<code>NS_DESIGNATED_INITIALIZER</code>来帮助我们约束定义方式，使得接口描述更加清晰。对于多个<code>init</code>方法，苹果给出了一个调用顺序，而我们也应该遵守这种调用顺序，以确保无论外部调用者从哪个入口进入，都能够正确的初始化：对于这种能初始化全部必需变量的方法，一般可作为<code>designed initializer</code>。所以，可以明确的告诉外部调用者，无论调用哪种初始化方法，最终，都会调用<code>designed initializer:</code>对于<code>NS_DESIGNATED_INITIALIZER</code>感兴趣的话可以了解下，这里就不在多说啦；</p></blockquote><blockquote><p>为什么只是在<code>- (instancetype)initWithFrame:(CGRect)frame</code>方法中添加子控件而不设置frame,反而在<code>- (void)layoutSubviews</code>设置frame呢？<br>当我们在某个类的内部调整子视图位置时，需要调用。</p></blockquote><ol><li>init初始化不会触发<code>layoutSubviews</code><br>但是用<code>initWithFrame</code>进行初始化时，当rect的值不为<code>CGRectZero</code>时,也会触发；</li><li><code>addSubview</code>会触发<code>layoutSubviews</code>；</li><li>设置view的Frame会触发<code>layoutSubviews</code>，当然前提是frame的值设置前后发生了变化；</li><li>滚动一个UIScrollView会触发<code>layoutSubviews</code>；</li><li>旋转Screen会触发父UIView上的<code>layoutSubviews</code>事件；</li><li>改变一个UIView大小的时候也会触发父UIView上的<code>layoutSubviews</code>事件；</li></ol><p>虽然两种方式最后都会调用到<code>initWithFrame:</code>方法。如果使用<code>init</code>方法创建，那么这个view的frame有可能是不确定的。</p><p>总结:</p><ol><li>新建一个继承UIVIew的类；</li><li>在实现文件中添加子控件（weak声明）；</li><li>重写<code>- (instancetype)initWithFrame:(CGRect)frame</code>初始化子控件但不设置子控件frame;</li><li>重写<code>- (void)layoutSubviews</code>，设置子控件frame，记得一定要写<code>[super layoutSubviews]</code>;</li><li>提供一个模型属性，在该模型的set方法中为子控件赋值；</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤 1：重写initWithFrame:方法，创建子控件并 - 添加</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UILabel</span> *lable = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">        lable.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">        <span class="keyword">self</span>.lable = lable;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:lable];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤 2：重写layoutSubviews，子控件设置frame</span></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.frame.size;</span><br><span class="line">    <span class="keyword">self</span>.lable.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * <span class="number">0.5</span>, size.height * <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-自定义UITableView不展示，cellForRowAtIndexPath不执行的问题&quot;&gt;&lt;a href=&quot;#1-自定义UITableView不展示，cellForRowAtIndexPath不执行的问题&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Xcode Configuration给一套代码展示不同图标和名称</title>
    <link href="https://gongbojie.com/2020/09/09/%E4%BD%BF%E7%94%A8Xcode-Configuration%E7%BB%99%E4%B8%80%E5%A5%97%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%E4%B8%8D%E5%90%8C%E5%9B%BE%E6%A0%87%E5%92%8C%E5%90%8D%E7%A7%B0/"/>
    <id>https://gongbojie.com/2020/09/09/使用Xcode-Configuration给一套代码展示不同图标和名称/</id>
    <published>2020-09-09T07:48:41.000Z</published>
    <updated>2020-09-09T09:33:49.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我们在开发一个项目中，会存在多个环境：开发环境，测试环境，正式环境。需要打出不同的安装包提供测试，这就需要不同的bundle id，并且最好是在手机上加以区分，app图标不同，app展示名称不同。</p><p>综上我们需要达成以下目标：</p><ol><li>构建不同的宏来方便切换相应的配置</li><li>配置三种数据环境（开发、测试、正式）根据宏的切换进行切换</li><li>三种图标/应用名称根据宏的切换进行切换显示</li><li>至少两个类型的包能同时安装在手机上</li></ol><p><img src="IMG_01.png" width="50%" height="50%"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>默认Xcode为每个target提供2个Build配置项(Build Configuration):Debug和Release。</p><h2 id="一、创建多个Configure"><a href="#一、创建多个Configure" class="headerlink" title="一、创建多个Configure"></a>一、创建多个Configure</h2><p>下图是两种创建Configure的方式</p><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="IMG_02.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">创建Configure的方式1</div><br></center><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="IMG_02.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">创建Configure的方式2</div><br></center><h2 id="二、数据环境的配置"><a href="#二、数据环境的配置" class="headerlink" title="二、数据环境的配置"></a>二、数据环境的配置</h2><p>新增了<code>TestVer</code>配置项之后，可以在当前<code>Target</code>的<code>Build Setting</code>下搜索<code>macros</code>找到<code>Preprocessor Macros</code>，可以看到我们刚刚Duplicate ‘Release’生成的<code>TestVer</code>的<code>Multiple Value</code>与<code>Release</code>的一模一样，这里我们需要新增<code>TESTVER=1</code>，来定义标示预发环境的宏变量TESTVER，主要是为了方便我们根据这里生成的宏在<code>.pch</code>文件中利用<code>#ifdef</code>来配置好相应的数据环境，这里同样可以将一些需要区分环境的第三方配置放进来，示意图及环境配置代码如下：<img src="IMG_04.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TESTVER <span class="comment">// 测试环境</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SERVER_URL_HEAD @<span class="meta-string">"http://xxx.xxx.xxx.xx:8181/SocialSecurity/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// 正式环境</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SERVER_URL_HEAD @<span class="meta-string">"http://xxx.xxx.xx.cn/SocialSecurity/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接着就可以在运行和打包模式下切换环境了</p><p><img src="IMG_05.png" alt=""></p><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="IMG_06.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">运行</div><br></center><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="IMG_07.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">打包</div><br></center><p>需要注意的问题:</p><p>正常情况下，以上步骤完成之后，如上图选择Edit Scheme切换Build Configuration就能编译出相应环境下的App，但是如果你的App使用pods来管理第三方库，使用新建的配置项就会报错找不到第三方的库文件。<br><img src="IMG_05.png" alt=""><br>原因是pods工程并未自动帮我们创建相应的pod配置项，发现这一点之后我手动创建了一个同样名为TestVer的pod配置项，于是编译通过了，但是打ipa包的时候始终通不过，继续查找原因，原来xcconfig文件需要终端执行pod install进行全面配置，所以大家在新建完了之后记得要pod install一下，才能放心使用。</p><h2 id="三、配置不同的AppIcon"><a href="#三、配置不同的AppIcon" class="headerlink" title="三、配置不同的AppIcon"></a>三、配置不同的AppIcon</h2><p>创建新的iOS App Icon并取名AppIconTestVer<br><img src="IMG_09.png" alt=""><br>然后再当前Target的Build Setting下搜索icon找到Asset Catalog App Icon Set Name，然后进行如下配置：<br><img src="IMG_10.png" alt=""><br>在Edit Scheme选择相应的Configuration进行编译或者打包就能打出不同的图标了。</p><h2 id="四、配置不同的AppName"><a href="#四、配置不同的AppName" class="headerlink" title="四、配置不同的AppName"></a>四、配置不同的AppName</h2><p>配置不同的应用名称，这里需要使用到User-Defined加上info.plist来进行配置；<br>首先，我们需要新增一个User-Defined，如下图：<br><img src="IMG_11.png" alt=""><br>将三种Configuration下的应用名分别设置。<br>然后在info.plist中加入Bundle display name，将其设置成我们刚刚新建的User-Defined:<br><img src="IMG_12.png" alt=""></p><p>可能出现的问题：<br>如果你的不小心引入了别的工程的InfoPlist.strings文件，它里面配置的bundle display name设置会覆盖掉你的User-Defined，使你的设置没有作用。</p><h2 id="五、配置不同的Bundle-ID"><a href="#五、配置不同的Bundle-ID" class="headerlink" title="五、配置不同的Bundle ID"></a>五、配置不同的Bundle ID</h2><p>为了使打出来的三种包能够共同存在同一台手机上，我们需要像配置应用名称一样，新建一个User-Defined来根据不同的Configuration使用不同的Bundle ID打包。<br>配置方法与配置应用名称一致。<br><img src="IMG_13.png" alt=""><br><img src="IMG_14.png" alt=""><br>配置完成之后，同一个App就能够在一台手机上面安装多个不同的包。</p><p>完</p><!-- 参考文章：https://www.cnblogs.com/gongyuhonglou/p/7766291.html -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;我们在开发一个项目中，会存在多个环境：开发环境，测试环境，正式环境。需要打出不同的安装包提供测试，这就需要不同的bundle id，并且最好
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用KVO为webView增加加载进度以及监听当前加载的地址</title>
    <link href="https://gongbojie.com/2020/03/09/%E4%BD%BF%E7%94%A8KVO%E4%B8%BAwebView%E5%A2%9E%E5%8A%A0%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%9B%91%E5%90%AC%E5%BD%93%E5%89%8D%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%9C%B0%E5%9D%80/"/>
    <id>https://gongbojie.com/2020/03/09/使用KVO为webView增加加载进度以及监听当前加载的地址/</id>
    <published>2020-03-09T13:57:48.000Z</published>
    <updated>2020-03-09T16:16:14.631Z</updated>
    
    <content type="html"><![CDATA[<ol><li>在wkWebView的懒加载中，增加进度监听</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//进度监听</span><br><span class="line">[_wkWebView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure><p>增加监听方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 监听加载</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123;</span><br><span class="line">        _loadingProgressView.progress = [change[@&quot;new&quot;] floatValue];</span><br><span class="line">        if (_loadingProgressView.progress == 1.0) &#123;</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                _loadingProgressView.hidden = YES;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在加载vue的hash模式提供的网页，webview的代理方法不能监听到点击事件，所以还是要通过kvo监听网页的点击事件</li></ol><p>同样在在wkWebView的懒加载中，增加webview加载URL的变化的监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 加载链接监听</span><br><span class="line">[_wkWebView addObserver:self forKeyPath:@&quot;URL&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><p>在监听方法 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ([keyPath isEqualToString:@&quot;URL&quot;]) &#123;</span><br><span class="line">    // 可以在这里进行拦截并做相应的处理</span><br><span class="line">    NSLog(@&quot;URL------%@&quot;,_wkWebView.URL.absoluteString);</span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(policyNewsWebViewCanGoBack:)]) &#123;</span><br><span class="line">        BOOL hiddenBack = [_wkWebView.URL.absoluteString containsString:@&quot;EpidemicConsultation&quot;];</span><br><span class="line">        [self.delegate policyNewsWebViewCanGoBack:hiddenBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二： 使用JS方法调用</p><p>webView的懒加载中，增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc]init];</span><br><span class="line">config.preferences = [[WKPreferences alloc] init];</span><br><span class="line">config.userContentController = [[WKUserContentController alloc]init];</span><br><span class="line">// 调用JS方法</span><br><span class="line">[config.userContentController addScriptMessageHandler:self  name:@&quot;changeRoute&quot;];</span><br></pre></td></tr></table></figure><p>在增加的WKScriptMessageHandler方法中调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    if ([message.name isEqualToString:@&quot;changeRoute&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,message.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的H5端需要增加相应的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.changeRoute.postMessage(<span class="string">'参数'</span>)</span><br></pre></td></tr></table></figure><p>方式三</p><p>使用JavaScriptCore：</p><p><img src="1.jpg" alt=""></p><p>在vue的项目中增加：</p><p><img src="2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;在wkWebView的懒加载中，增加进度监听&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>随着稻香河流继续奔跑🏃</title>
    <link href="https://gongbojie.com/2020/02/16/%E3%80%8C%E9%9A%8F%E7%9D%80%E7%A8%BB%E9%A6%99%E6%B2%B3%E6%B5%81%E7%BB%A7%E7%BB%AD%E5%A5%94%E8%B7%91%F0%9F%8F%83%E3%80%8D/"/>
    <id>https://gongbojie.com/2020/02/16/「随着稻香河流继续奔跑🏃」/</id>
    <published>2020-02-16T10:26:59.000Z</published>
    <updated>2020-02-16T10:33:57.557Z</updated>
    
    <content type="html"><![CDATA[<p>  “hey siri，播放音乐”</p><p>  耳边响起《稻香》这首歌，以前对这首歌无感，但是神奇的是，突然的响起，最近焦虑的阴霾也突然变逐渐散去。<br>  <!-- 最近疫情影响，工作在家处理，手头的一个项目的工作还没有完成，另一个需求又来了。  自己的问题，团队的问题，工作的繁乱，公司新组建部门的工作任务推脱，再加上非常时期工作岗位不好找，还有自己的面试准备根本不到位。 --><br>  工作、跳槽、团队沟通。出现的问题混在一起。<br>  导致心情的消极。</p><p>  “请你打开电视看看，多少人为生命在努力勇敢的走下去”<br>  从微博上看到一位有身体残疾的外卖小哥，美团账号被封，还努力的靠着自己的劳动挣钱。很乐观地面对困难。<br>  「每一个努力活着的人都值得被尊重」<br>  想想自己，又是什么事情烦恼着我们呢<br>  挣更多💰，还有想要更好的生活。</p><p>  有困难，我们就面对困难，这困难又不是关乎生命没有办法解决的事情。<br>  当人健康的时候，有很多愿望；而当人生病的时候，就只有一个愿望了。</p><p>  工作上遇到问题那我们就去解决工作的问题，团队上遇到问题，那我们就去解决沟通的问题。换工作的话，那我们就着手去准备换工作刷题，复习知识。<br>  归根结底，就是遇到问题想尽办法去解决，消极的状态也改变不了什么。</p><p>  「微微笑，随着稻香河流继续奔跑吧」</p><p>  消极的时候，调整心态，听听这首歌，并且大声说一句 「奥力给！」吧（笑😂虽然俗了点，但确实有用）。</p><p>  🕊️&amp;💗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  “hey siri，播放音乐”&lt;/p&gt;
&lt;p&gt;  耳边响起《稻香》这首歌，以前对这首歌无感，但是神奇的是，突然的响起，最近焦虑的阴霾也突然变逐渐散去。&lt;br&gt;  &lt;!-- 最近疫情影响，工作在家处理，手头的一个项目的工作还没有完成，另一个需求又来了。
  自己的问题，团
      
    
    </summary>
    
    
      <category term="life" scheme="https://gongbojie.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>JS与iOS WKWebView交互</title>
    <link href="https://gongbojie.com/2020/02/06/JS%E4%B8%8EiOS%E4%BA%A4%E4%BA%92/"/>
    <id>https://gongbojie.com/2020/02/06/JS与iOS交互/</id>
    <published>2020-02-06T08:47:01.000Z</published>
    <updated>2020-02-06T10:52:40.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS调用iOS-WKWebView原生API"><a href="#JS调用iOS-WKWebView原生API" class="headerlink" title="JS调用iOS WKWebView原生API"></a>JS调用iOS WKWebView原生API</h1><p> 添加监听代理和JS接口</p><p>在OC中添加监听的接口代码：以JS脚本的接口 <code>btnClose</code> 为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般写在初始化WKWebView处</span></span><br><span class="line"><span class="built_in">WKWebViewConfiguration</span> *config = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line"><span class="built_in">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class="line"><span class="comment">//MARK:在OC中添加监听的接口代码：JS脚本的接口名</span></span><br><span class="line">[userCC addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"btnClose"</span>];</span><br></pre></td></tr></table></figure><p>设置WKUserContentController的代理</p><p>设置代理类遵守WKScriptMessageHandler协议</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">WKScriptMessageHandler</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注册对JS接口监听，注入代理类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[userCC addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"btnClose"</span>];</span><br></pre></td></tr></table></figure><p>实现WKUserContentController代理的回调方法,响应JS接口事件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    <span class="keyword">if</span> ([message.name isEqualToString:<span class="string">@"btnClose"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message.body);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS脚本接口</p><p>JS接口声明格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.接口名.postMessage(<span class="string">'参数'</span>)</span><br></pre></td></tr></table></figure><p>接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。</p><p>参数：object类型，多个参数时需要封装为集合类型来实现多参传递。</p><p>当OC拦截到该接口时，可以在WKScriptMessageHandler回调方法中的WKScriptMessage参数实例中获取该参数值: message.body。</p><p>三个例子：</p><ol><li>JS无参调用OC</li></ol><p>当无参调用OC时，参数必须为null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.btnClose.postMessage(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>JS传参调用OC</li></ol><p>传递单个参数时，直接写入即可，例如：lil gong</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.showName.postMessage(<span class="string">'lil gong'</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>传递多个参数时，需要封装为集合类型实现多参传递。</li></ol><p>例如:当传递一个电话，一条信息，需要封装为[‘18600000000’,’Go Camping!!!’]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.showSendMsg.postMessage([<span class="string">'18600000000'</span>, <span class="string">'Go Camping!!!'</span>])</span><br></pre></td></tr></table></figure><h1 id="iOS原生API调用JS脚本"><a href="#iOS原生API调用JS脚本" class="headerlink" title="iOS原生API调用JS脚本"></a>iOS原生API调用JS脚本</h1><p>在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。<br>例如调用JS函数<code>alertMobile()：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.wkWebView evaluateJavaScript:@&quot;alertMobile()&quot; completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">    //TODO</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,response,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在OC中为JS定义属性/函数</p><ul><li>当注入的类型字符串类型时，必须用’’括起来。</li><li>OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。</li></ul><p>通过NSString形式，编写JS脚本，通过以下两种方式注入网页</p><p>方式一：在初始化WKWebView时，通过配置WKWebViewConfiguration的userContentController注入JS脚本 。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK:向网页中注入JS脚本例如，参数/函数等</span></span><br><span class="line"><span class="built_in">WKUserScript</span> *script = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:<span class="string">@"var number = 0;"</span> injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class="line">[userCC addUserScript:script];</span><br></pre></td></tr></table></figure><p>方式二：使用WKWebView实例方法evaluateJavaScript动态注入JS脚本</p><p>通常情况下在页面加载完成时注入</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation &#123;</span><br><span class="line">    [<span class="keyword">self</span>.wkWebView evaluateJavaScript:<span class="string">@"var number = 0;"</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止放大缩小</span></span><br><span class="line">    <span class="built_in">NSString</span> *urlString = [webView.URL absoluteString];</span><br><span class="line">    <span class="keyword">if</span> (![urlString containsString:<span class="string">@"SiEquityRecordQuery"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *injectionJSString = <span class="string">@"var script = document.createElement('meta');"</span></span><br><span class="line">        <span class="string">"script.name = 'viewport';"</span></span><br><span class="line">        <span class="string">"script.content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\";"</span></span><br><span class="line">        <span class="string">"document.getElementsByTagName('head')[0].appendChild(script);"</span>;</span><br><span class="line">        [webView evaluateJavaScript:injectionJSString completionHandler:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//导航栏配置</span></span><br><span class="line">    [webView evaluateJavaScript:<span class="string">@"document.title"</span> completionHandler:^(<span class="keyword">id</span> _Nullable title, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line"><span class="comment">//        self.navigationItem.title = title;</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS调用iOS-WKWebView原生API&quot;&gt;&lt;a href=&quot;#JS调用iOS-WKWebView原生API&quot; class=&quot;headerlink&quot; title=&quot;JS调用iOS WKWebView原生API&quot;&gt;&lt;/a&gt;JS调用iOS WKWebView原生A
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS推送证书相关</title>
    <link href="https://gongbojie.com/2020/02/06/iOS%E6%8E%A8%E9%80%81%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3/"/>
    <id>https://gongbojie.com/2020/02/06/iOS推送证书相关/</id>
    <published>2020-02-06T07:37:56.000Z</published>
    <updated>2020-02-08T09:47:38.691Z</updated>
    
    <content type="html"><![CDATA[<p>iOS的推送证书有两种： <code>iOS Development</code>和<code>iOS Distribution</code>，一般开发式使用<code>iOS Development</code>，测试真是环境<code>(Distribution)</code>的话，必须是：</p><ol><li>Download app from <strong>App store</strong></li><li>Download app from <strong>TestFlight</strong></li><li><strong>AdHoc</strong></li></ol><p>拥有<code>Admin</code>以上权限的<code>Apple Developer</code></p><p>首先，要先有 <code>distribution certificate</code>，到 <a href="https://developer.apple.com/" target="_blank" rel="noopener">Apple Developer</a> 登录 -&gt; <code>Certificates</code>, <code>Identifiers &amp; Profiles</code>-&gt; <code>Certificates</code> ，选择<code>Production</code>，照着步骤新增<code>Certificate</code>。</p><p>接着到<code>Provisioning Profiles</code>-&gt; <code>Distribution</code>，建立一个<code>AdHoc</code>的<code>Distribution</code>。一步步完成后进行下载到本地后，双击进行安装。</p><p>接着到你的<code>iOS project</code>，<code>Target</code>-&gt;<code>General</code>的<code>Signing</code>选择对应的<code>provisionProfile</code>。</p><p>以上设置完成以后，接着就到<code>Product</code>-&gt; <code>Archive</code> ，<code>Build successful</code>后选择<code>Distribute App</code>。</p><p><img src="IMG_01.png" alt=""></p><p>一步步完成后就可以<code>Export</code>出來了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS的推送证书有两种： &lt;code&gt;iOS Development&lt;/code&gt;和&lt;code&gt;iOS Distribution&lt;/code&gt;，一般开发式使用&lt;code&gt;iOS Development&lt;/code&gt;，测试真是环境&lt;code&gt;(Distribution)&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>适配iOS13相关Tips</title>
    <link href="https://gongbojie.com/2019/11/21/%E9%80%82%E9%85%8DiOS13%E7%9B%B8%E5%85%B3Tips/"/>
    <id>https://gongbojie.com/2019/11/21/适配iOS13相关Tips/</id>
    <published>2019-11-21T07:40:46.000Z</published>
    <updated>2020-03-09T14:21:52.529Z</updated>
    
    <content type="html"><![CDATA[<ol><li>模拟器调试暗黑模式</li></ol><p>打开模拟器-设置-开发者：<img src="IMG_01.png" alt=""> 打开选项，即可开启暗黑模式</p><ol start="2"><li>app禁止暗黑模式</li></ol><p>在info.plist中，增加一行key为User Interface Style value为Light，这样你的app就不会跟随手机设置的模式而改变了<br><img src="IMG_02.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIUserInterfaceStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Light&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>ios13下模态跳转presentViewController</li></ol><p>在ios13下，苹果将 presentViewController默认的style改成了 UIModalPresentationAutomatic之前的是 UIModalPresentationFullScreen ，所以需要加一行代码，手动去选择<br><code>vc.modalPresentationStyle = UIModalPresentationFullScreen;</code><br><img src="IMG_03.png" alt=""></p><ol start="4"><li>ios13下获取状态栏的高度</li></ol><p>之前在APPDelegate下无法获取到，需要在界面加载完成的viewDidLoad后，才会获取到，这样处理，可以解决</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="comment">//写在super之前，可以更好的保证，在当前界面加载之前，将状态栏高度获取到</span></span><br><span class="line">    <span class="comment">//主要当时是将状态栏的高度注入JS，给H5调用，在super之后，web已经加载好了，高度获取的时机晚了</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] statusBarFrame].size.height；</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>获取searchBar中的TextField方法更改，会引起崩溃</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前代码</span></span><br><span class="line">    <span class="built_in">UITextField</span> * searchField = [searchBar valueForKey:<span class="string">@"_searchField"</span>];</span><br><span class="line">    <span class="built_in">UILabel</span> *searchPlaceLabel = [searchField valueForKey:<span class="string">@"placeholderLabel"</span>];</span><br><span class="line">    searchPlaceLabel.textColor = [<span class="built_in">UIColor</span> colorWithHex:<span class="string">@"#999999"</span>];</span><br><span class="line">    [searchField setValue:[<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">14</span>] forKeyPath:<span class="string">@"_placeholderLabel.font"</span>];</span><br></pre></td></tr></table></figure><p>ios13之后把SearchBar中的textField直接暴露给开发者使用,无需在通过kvc获取。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后</span></span><br><span class="line">    <span class="built_in">UITextField</span> * searchField = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">13.0</span>, *)) &#123;</span><br><span class="line">        searchField =searchBar.searchTextField;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        searchField = [searchBar valueForKey:<span class="string">@"_searchField"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *arrStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:searchField.placeholder attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>],<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> colorWithHex:<span class="string">@"#999999"</span>]&#125;];</span><br><span class="line">    searchField.attributedPlaceholder = arrStr;</span><br></pre></td></tr></table></figure><ol start="6"><li>获取statusBar，方法更新如下，会引起崩溃</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">13.0</span>, *)) &#123;</span><br><span class="line">    <span class="built_in">UIStatusBarManager</span> *statusBarManager = [<span class="built_in">UIApplication</span> sharedApplication].keyWindow.windowScene.statusBarManager;</span><br><span class="line">    <span class="keyword">if</span> ([statusBarManager respondsToSelector:<span class="keyword">@selector</span>(createLocalStatusBar)]) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *_localStatusBar = [statusBarManager performSelector:<span class="keyword">@selector</span>(createLocalStatusBar)];</span><br><span class="line">        <span class="keyword">if</span> ([_localStatusBar respondsToSelector:<span class="keyword">@selector</span>(statusBar)]) &#123;</span><br><span class="line">            _statusBar = [_localStatusBar performSelector:<span class="keyword">@selector</span>(statusBar)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">    _statusBar = [[[<span class="built_in">UIApplication</span> sharedApplication] valueForKey:<span class="string">@"statusBarWindow"</span>] valueForKey:<span class="string">@"statusBar"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>iOS13设置 UITabBarItem的选中颜色无效</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">10.0</span>, *)) &#123;</span><br><span class="line"><span class="keyword">self</span>.tabBar.unselectedItemTintColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fallback on earlier versions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;模拟器调试暗黑模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开模拟器-设置-开发者：&lt;img src=&quot;IMG_01.png&quot; alt=&quot;&quot;&gt; 打开选项，即可开启暗黑模式&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;app禁止暗黑模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在in
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift中的宏定义</title>
    <link href="https://gongbojie.com/2019/09/09/Swift%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>https://gongbojie.com/2019/09/09/Swift中的宏定义/</id>
    <published>2019-09-09T07:52:33.000Z</published>
    <updated>2019-09-09T08:03:15.397Z</updated>
    
    <content type="html"><![CDATA[<p><code>Swift</code>中是不能使用宏定义语法的，但是因为命名空间的缘故，我们可以给我们的项目添加一个空的<code>Const.swift</code>文件，在其中，我们将原本<code>oc</code>中不需要接受参数的宏，定义成<code>let</code>常量，将需要接受参数的宏定义成函数即可，由于我们的整个项目共享命名空间，我们就可以在项目内的任何地方直接使用<code>Const.swift</code>中定义的这些公共的常量和函数</p><ol><li>没有参数的宏</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oc中的宏定义</span></span><br><span class="line">#define kIOS7   [<span class="type">UIDevice</span> currentDevice].systemVersion.doubleValue&gt;=<span class="number">7.0</span> ? <span class="number">1</span> :<span class="number">0</span></span><br><span class="line">#define kIOS8   [<span class="type">UIDevice</span> currentDevice].systemVersion.doubleValue&gt;=<span class="number">8.0</span> ? <span class="number">1</span> :<span class="number">0</span></span><br><span class="line">#define kScreenHeight     [<span class="type">UIScreen</span> mainScreen].bounds.size.height</span><br><span class="line">#define kScreenWidth      [<span class="type">UIScreen</span> mainScreen].bounds.size.width</span><br><span class="line"><span class="comment">//转换成swift的写法</span></span><br><span class="line"><span class="keyword">let</span> kIOS7 = <span class="type">Double</span>(<span class="type">UIDevice</span>().systemVersion)&gt;=<span class="number">7.0</span> ? <span class="number">1</span> :<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> kIOS8 = <span class="type">Double</span>(<span class="type">UIDevice</span>().systemVersion)&gt;=<span class="number">8.0</span> ? <span class="number">1</span> :<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kScreenHeight = <span class="type">UIScreen</span>.mainScreen().bounds.size.height</span><br><span class="line"><span class="keyword">let</span> kScreenWidth = <span class="type">UIScreen</span>.mainScreen().bounds.size.width</span><br></pre></td></tr></table></figure><ol start="2"><li>接收参数的宏</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oc写法</span></span><br><span class="line">#define <span class="type">RGBCOLOR</span>(r,g,b) [<span class="type">UIColor</span> colorWithRed:(r)/<span class="number">255.0</span> green:(g)/<span class="number">255.0</span> blue:(b)/<span class="number">255.0</span> alpha:<span class="number">1</span>]</span><br><span class="line"><span class="comment">//swift中的写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RGBCOLOR</span><span class="params">(r:CGFloat,<span class="number">_</span> g:CGFloat,<span class="number">_</span> b:CGFloat)</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIColor</span>(red: (r)/<span class="number">255.0</span>, green: (g)/<span class="number">255.0</span>, blue: (b)/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;中是不能使用宏定义语法的，但是因为命名空间的缘故，我们可以给我们的项目添加一个空的&lt;code&gt;Const.swift&lt;/code&gt;文件，在其中，我们将原本&lt;code&gt;oc&lt;/code&gt;中不需要接受参数的宏，定义成&lt;code&gt;let&lt;/co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>隐私政策</title>
    <link href="https://gongbojie.com/2019/06/06/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
    <id>https://gongbojie.com/2019/06/06/隐私政策/</id>
    <published>2019-06-06T09:08:29.000Z</published>
    <updated>2019-06-06T09:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><ol><li>适用范围</li></ol><p>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；<br>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；<br>(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。</p><p>您了解并同意，以下信息不适用本隐私权政策：</p><p>(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；<br>(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；<br>(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p><ol start="2"><li>信息使用</li></ol><p>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。<br>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。<br>(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。</p><ol start="3"><li>信息披露在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：</li></ol><p>(a) 经您事先同意，向第三方披露；<br>(b) 为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；<br>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；<br>(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；<br>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；<br>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。<br>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p><ol start="4"><li><p>信息存储和交换本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p></li><li><p>Cookie的使用</p></li></ol><p>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。<br>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。<br>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p><ol start="6"><li>信息安全</li></ol><p>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。<br>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对</p><ol start="7"><li>本隐私政策的更改</li></ol><p>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。<br>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p><p>方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>工具使用小Tips记录</title>
    <link href="https://gongbojie.com/2019/03/07/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%B0%8FTips%E8%AE%B0%E5%BD%95/"/>
    <id>https://gongbojie.com/2019/03/07/工具使用小Tips记录/</id>
    <published>2019-03-07T03:37:00.000Z</published>
    <updated>2020-04-28T02:39:54.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdowm"><a href="#Markdowm" class="headerlink" title="Markdowm"></a>Markdowm</h1><ol><li>markdown导出pdf时候强制换页，插入以下代码</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div STYLE="page-break-after: always;"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>手动触发tabbar的item</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// You can set the default index of the TabBarController by setting the selectedIndex property. This can be put in viewDidLoad or Before pushing the controller if you are doing it that way. This is done only when you are using a TabBarController and Not just a TabBar.</span><br><span class="line">tabBarController.selectedIndex = 1;</span><br><span class="line">// If you are using a TabBar without a TabBarController then you have to do it like this.</span><br><span class="line">self.tabBar.selectedItem = [self.tabBar.items objectAtIndex:1];</span><br></pre></td></tr></table></figure><h1 id="iOS相关"><a href="#iOS相关" class="headerlink" title="iOS相关"></a>iOS相关</h1><h2 id="1-iOS-AFN网络请求失败401时，如何获取后台返回的内容"><a href="#1-iOS-AFN网络请求失败401时，如何获取后台返回的内容" class="headerlink" title="1. iOS AFN网络请求失败401时，如何获取后台返回的内容"></a>1. iOS AFN网络请求失败401时，如何获取后台返回的内容</h2><p>开发中，会遇到当接口非200时，也需要去取后台返回的数据，以便客户端提示用。那怎拿到呢？就是在failure的回调里，加上下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSData *errorData = [error.userInfo objectForKey:AFNetworkingOperationFailingURLResponseDataErrorKey];</span><br><span class="line"></span><br><span class="line">NSString *responseString  = [[NSString alloc] initWithData:errorData encoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure><p>responseString字符串格式就是接口返回的内容。还可以转成字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:errorData options:NSJSONReadingAllowFragments error:nil];</span><br></pre></td></tr></table></figure><h2 id="2-实现TableViewCell的单选"><a href="#2-实现TableViewCell的单选" class="headerlink" title="2. 实现TableViewCell的单选"></a>2. 实现TableViewCell的单选</h2><p>利用cell的<code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated</code>方法</p><p>优点：不用任何外在属性，不用变量，不用数组。实现cell、或cell中Button的单选。并且不会因为复用而造成位置错乱。</p><p>实现方式：</p><ol><li>如果要有默认选择在初始化tableView完成后写</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0];</span><br><span class="line">[self.tableView selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone];</span><br></pre></td></tr></table></figure><ol start="2"><li>然后在cell中实现- (void)setSelected:(BOOL)selected animated:(BOOL)animated方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123;</span><br><span class="line">    [super setSelected:selected animated:animated];</span><br><span class="line">    if (selected) &#123;</span><br><span class="line">        self.selBtn.selected = YES;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        self.selBtn.selected = NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>didSelectRowAtIndexPath</code>方法中给点击的cell手动选中，并不需要刷新表格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tableView selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone];</span><br></pre></td></tr></table></figure><h2 id="3-实现cell多选"><a href="#3-实现cell多选" class="headerlink" title="3. 实现cell多选"></a>3. 实现cell多选</h2><ul><li>把tableView的allowsMultipleSelection 属性设为了YES；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tableView.allowsMultipleSelection = YES;</span><br></pre></td></tr></table></figure><ul><li>在 didSelectRowAtIndexPath 和 didDeselectRowAtIndexPath 方法里面使用了如下方法实现了点击单元格然后用check mark 标记的方式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line"></span><br><span class="line">      UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">  cell.accessoryType = UITableViewCellAccessoryCheckmark;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">[tableView cellForRowAtIndexPath:indexPath].accessoryType = UITableViewCellAccessoryNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止复用的思路</p><ol><li>记录选择的indexpath</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1.设一个NSMutableArray属性，元素个数跟你的_dataArray一样，初始化里面存的都是0。</span><br><span class="line"> </span><br><span class="line"> NSMutableArray* selectionArray = [NSMutableArray array];</span><br><span class="line"> for (NSInteger i = 0; i &lt; _dataArray.count; i++) &#123;</span><br><span class="line">    [selectionArray addObject:@(0)]; // 0 表示未选中，1 表示选中了</span><br><span class="line"> &#125;</span><br><span class="line"> self.selectionArray = selectionArray; </span><br><span class="line"> </span><br><span class="line">   // 2.在 didSelectRowAtIndexPath:里</span><br><span class="line">   </span><br><span class="line"> [self.selectionArray replaceObjectAtIndex:indexPath.row withObject:@(1)];</span><br><span class="line"></span><br><span class="line"> [self.tableView reloadData];</span><br><span class="line"></span><br><span class="line">   // 3.在 didDeselectRowAtIndexPath里：</span><br><span class="line">   </span><br><span class="line"> [self.selectionArray replaceObjectAtIndex:indexPath.row withObject:@(0)];</span><br><span class="line"></span><br><span class="line"> [self.tableView reloadData];</span><br><span class="line"></span><br><span class="line">   // 4.在 cellForRow里：</span><br><span class="line">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];</span><br><span class="line">cell.textLabel.text = _dataArray[indexPath.row];</span><br><span class="line">NSInteger selected = [self.selectionArray[indexPath.row] IntegerValue];</span><br><span class="line">if (selected == 0) &#123;</span><br><span class="line">    cell.accessoryType = UITableViewCellAccessoryNone;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cell.accessoryType = UITableViewCellAccessoryCheckmark;</span><br><span class="line">&#125;</span><br><span class="line">return cell;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用cell的selected属性</li></ol><ul><li>继承UITableViewCell，在setSeleted:animated:方法里面，根据选择状态，修改accessoryType</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123;</span><br><span class="line">    [super setSelected:selected animated:animated];</span><br><span class="line">    self.accessoryType = selected?UITableViewCellAccessoryCheckmark:UITableViewCellAccessoryNone;</span><br><span class="line">    // Configure the view for the selected state</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 在 cellForRow里：</span><br><span class="line">cell.accessoryType = cell.selected?UITableViewCellAccessoryCheckmark:UITableViewCellAccessoryNone;</span><br></pre></td></tr></table></figure><p>解决因为复用所导致的问题</p><p>tableView的一些设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 设置tableView可不可以选中</span><br><span class="line">self.tableView.allowsSelection = NO;</span><br><span class="line"></span><br><span class="line">// 允许tableview多选</span><br><span class="line">self.tableView.allowsMultipleSelection = YES;</span><br><span class="line"></span><br><span class="line">// 编辑模式下是否可以选中</span><br><span class="line">self.tableView.allowsSelectionDuringEditing = NO;</span><br><span class="line"></span><br><span class="line">// 编辑模式下是否可以多选</span><br><span class="line">self.tableView.allowsMultipleSelectionDuringEditing = YES;</span><br><span class="line"></span><br><span class="line">// 获取被选中的所有行</span><br><span class="line">[self.tableView indexPathsForSelectedRows]</span><br><span class="line"></span><br><span class="line">// 获取当前可见的行</span><br><span class="line">[self.tableView indexPathsForVisibleRows];</span><br></pre></td></tr></table></figure><h2 id="4-属性修饰词"><a href="#4-属性修饰词" class="headerlink" title="4. 属性修饰词"></a>4. 属性修饰词</h2><p>当修饰可变类型的属性时，如<code>NSMutableArray</code>、<code>NSMutableDictionary</code>、<code>NSMutableString</code>，用<code>strong</code>。</p><p>当修饰不可变类型的属性时，如<code>NSArray</code>、<code>NSDictionary</code>、<code>NSString</code>，用<code>copy</code>。</p><h2 id="5-iOS返回到指定页面的方法"><a href="#5-iOS返回到指定页面的方法" class="headerlink" title="5. iOS返回到指定页面的方法"></a>5. iOS返回到指定页面的方法</h2><ol><li>返回到指定页面 但不是根界面的某个页面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UserViewController *homeVC = [[UserViewController alloc] init];</span><br><span class="line">UIViewController *target = nil;</span><br><span class="line">for (UIViewController * controller in self.navigationController.viewControllers) &#123; </span><br><span class="line">  if ([controller isKindOfClass:[homeVC class]]) &#123; </span><br><span class="line">    target = controller;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target) &#123;</span><br><span class="line">  [self.navigationController popToViewController:target animated:YES]; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>返回根页面的某个页面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController.tabBarController.hidesBottomBarWhenPushed=NO;</span><br><span class="line">self.navigationController.tabBarController.selectedIndex=0;</span><br><span class="line">[self.navigationController popToRootViewControllerAnimated:YES];</span><br></pre></td></tr></table></figure><ol start="3"><li>返回上两级页面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (self.navigationController.viewControllers.count &gt;= 2) &#123;</span><br><span class="line">  UIViewController *vc = [self.navigationController.viewControllers  objectOrNilAtIndex:1];</span><br><span class="line">  [self.navigationController popToViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><p>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)</p><p>沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)</p><p>沙盒中常用的几个路径:<br>Document文件夹：<br>用来保存应由程序运行时生成的需要持久化的数据， iTunes会自动备份该目录（苹果公司建议将程序中创建的和浏览过的程序存放在这里，iTunes在备份和回复时会自动包含此目录）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//文件路径是数组，这里取第一个元素</span><br><span class="line">NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];</span><br></pre></td></tr></table></figure><p>Library文件夹：<br>用来存储程序的默认设置和其他状态信息，iTunes也会自动备份该目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *libraryPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)[0];</span><br></pre></td></tr></table></figure><p>Library/Caches:<br>用来存放缓存文件，iTunes不会备份此目录，此目录下的文件不会在程序退出后删除，一般存放体积比较大但又不太重要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</span><br></pre></td></tr></table></figure><p>Library/Preferences:<br>用来存储用户的偏好设置，iOS的setting（设置）会在这个目录中查找应用程序的设置信息，iTunes会自动备份该目录，通常这个文件夹都是由系统进行维护的，建议不要操作他。<br>系统没有直接获取这个文件夹路径的方法,需要先获取Library路径然后进行字符串拼接找到此路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *libraryPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDoMainMask, YES)[0]; </span><br><span class="line">NSString*preferencePath = [libraryPath stringByAppendingString:@&quot;/Preferences&quot;];</span><br></pre></td></tr></table></figure><p>注意：不要直接写偏好设置到这个文件夹，而是通过NSUserDefaults来进行偏好设置的保存和读取。</p><p>tmp：<br>保存应用程序的临时文件夹，使用完毕后，将相应的文件从这个目录中删除，如果空间不够，系统也可能会删除这个目录下的文件，iTunes不会同步这个文件夹，在iPhone重启的时候，该目录下的文件会被删除。<br>这个路径的获取方法和其他的不同,它有自己方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *tmpPath = NSTemporaryDirectory();</span><br></pre></td></tr></table></figure><p>模拟器沙盒查看 <code>(lldb) po NSHomeDirectory()</code></p><p>清理<code>/Library/Caches</code>目录文件,理论上来讲是没错，所有的缓存文件都会放在app沙盒目录的Caches文件目录下，<strong><em>这样的清理模拟器能通过，真机则会因为没有Snapshot的访问权限而中止清理。</em></strong></p><p>所以实际应用中我们的计算缓存大小函数，以及清理函数需要跳过Snapshot这个文件目录，不讲目录文件大小计入缓存大小，清理的时候跳过该目录防止中断。</p><p><code>clearCacheTool.m</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark - 获取Cache文件夹大小</span><br><span class="line">+ (NSString *)getCacheSize &#123;</span><br><span class="line">    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">    NSString *totleSize = [ClearCachesTool getCacheSizeWithFilePath:cachesPath];</span><br><span class="line">    return totleSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 删除Cache文件夹中的缓存</span><br><span class="line">+ (BOOL)clearCache &#123;</span><br><span class="line">    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];</span><br><span class="line">    BOOL isAlreadyClearCache = [ClearCachesTool clearCacheWithFilePath:cachesPath];</span><br><span class="line">    return isAlreadyClearCache;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)readyClearCache &#123;</span><br><span class="line">    BOOL isClearCache = [ClearCachesTool clearCache];</span><br><span class="line">    if (isClearCache) &#123;</span><br><span class="line">        NSLog(@&quot;清理完毕&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;清理失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 获取path路径下文件夹大小</span><br><span class="line">+ (NSString *)getCacheSizeWithFilePath:(NSString *)path &#123;</span><br><span class="line"></span><br><span class="line">    // 获取“path”文件夹下的所有文件</span><br><span class="line">    NSArray *subPathArr = [[NSFileManager defaultManager] subpathsAtPath:path];</span><br><span class="line">    NSString *filePath  = nil;</span><br><span class="line">    NSInteger totleSize = 0;</span><br><span class="line">    for (NSString *subPath in subPathArr)&#123;</span><br><span class="line">//        NSLog(@&quot;getCacheSize = %@&quot;,subPath);</span><br><span class="line">        // 0. 把Snapshots文件夹过滤掉,没有访问权限,否则删除时操过200M会失败!!!!!!!!</span><br><span class="line">        if (![subPath containsString:@&quot;Snapshots&quot;]) &#123;</span><br><span class="line">            // 1. 拼接每一个文件的全路径</span><br><span class="line">            filePath =[path stringByAppendingPathComponent:subPath];</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 是否是文件夹，默认不是</span><br><span class="line">        BOOL isDirectory = NO;</span><br><span class="line">        // 3. 判断文件是否存在</span><br><span class="line">        BOOL isExist = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&amp;isDirectory];</span><br><span class="line">        // 4. 以上判断目的是忽略不需要计算的文件</span><br><span class="line">        if (!isExist || isDirectory || [filePath containsString:@&quot;.DS&quot;])&#123;</span><br><span class="line">            // 过滤: 1. 文件夹不存在  2. 过滤文件夹  3. 隐藏文件</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5. 指定路径，获取这个路径的属性</span><br><span class="line">        NSDictionary *dict = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">        /**</span><br><span class="line">         attributesOfItemAtPath: 文件夹路径</span><br><span class="line">         该方法只能获取文件的属性, 无法获取文件夹属性, 所以也是需要遍历文件夹的每一个文件的原因</span><br><span class="line">         */</span><br><span class="line">        // 6. 获取每一个文件的大小</span><br><span class="line">        NSInteger size = [dict[@&quot;NSFileSize&quot;] integerValue];</span><br><span class="line">        // 7. 计算总大小</span><br><span class="line">        totleSize += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8. 将文件夹大小转换为 M/KB/B</span><br><span class="line">    NSString *totleStr = nil;</span><br><span class="line">    if (totleSize &gt; 1000 * 1000)&#123;</span><br><span class="line">        totleStr = [NSString stringWithFormat:@&quot;%.2fM&quot;,totleSize / 1000.00f /1000.00f];</span><br><span class="line">    &#125;else if (totleSize &gt; 1000)&#123;</span><br><span class="line">        totleStr = [NSString stringWithFormat:@&quot;%.2fKB&quot;,totleSize / 1000.00f ];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        totleStr = [NSString stringWithFormat:@&quot;%.2fB&quot;,totleSize / 1.00f];</span><br><span class="line">    &#125;</span><br><span class="line">    return totleStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 清除path文件夹下缓存大小--/Caches/Snapshots,真机测试会输出error</span><br><span class="line">//Error Domain=NSCocoaErrorDomain Code=513 &quot;未能移除“Snapshots”，因为您没有访问它的权限。&quot;</span><br><span class="line">+ (BOOL)clearCacheWithFilePath:(NSString *)path&#123;</span><br><span class="line"></span><br><span class="line">    //拿到path路径的下一级目录的子文件夹</span><br><span class="line">    NSArray *subPathArr = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:nil];</span><br><span class="line">    NSString *filePath = nil;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    for (NSString *subPath in subPathArr) &#123;</span><br><span class="line">        filePath = [path stringByAppendingPathComponent:subPath];</span><br><span class="line">//        NSLog(@&quot;%@&quot;,filePath);</span><br><span class="line">        if (![filePath containsString:@&quot;/Caches/Snapshots&quot;]) &#123;</span><br><span class="line">            //删除子文件夹</span><br><span class="line">            [[NSFileManager defaultManager] removeItemAtPath:filePath error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;,error);</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  caches文件夹下缓存大小</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString *cachesSize;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self getCachesSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 获取Caches文件夹缓存大小</span><br><span class="line">- (void)getCachesSize &#123;</span><br><span class="line">    // 子线程计算文件缓存</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">        NSString *cachesSize = [ClearCachesTool getCacheSize];</span><br><span class="line">        self.cachesSize = cachesSize;</span><br><span class="line">        // 主线程更新显示</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           // cell.detailTextLabel.text = cachesSize;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 删除Caches文件夹缓存</span><br><span class="line">- (void)clearCaches &#123;</span><br><span class="line">    // 子线程做删除耗时操作</span><br><span class="line">    if (self.cachesSize == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *message = [NSString stringWithFormat:@&quot;缓存大小为%@,确定要清理吗?&quot;,self.cachesSize];</span><br><span class="line"></span><br><span class="line">    UIAlertController *alertC = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:message preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil];</span><br><span class="line">    UIAlertAction *certain = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        [SVProgressHUD showWithStatus:@&quot;正在拼命清理中...&quot;];</span><br><span class="line"></span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            [ClearCachesTool clearCache];</span><br><span class="line">            // 主线程刷新显示</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [SVProgressHUD dismiss];</span><br><span class="line">                self.cachesSize = nil;</span><br><span class="line">                cell.detailTextLabel.text = @&quot;清理完毕&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [alertC addAction:cancel];</span><br><span class="line">    [alertC addAction:certain];</span><br><span class="line">    [self presentViewController:alertC animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 点击按钮触发是否更新提示</span><br><span class="line">- (void)clearClick &#123;</span><br><span class="line">    [self clearCaches];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在程序的启动时强制更改程序语言设置"><a href="#在程序的启动时强制更改程序语言设置" class="headerlink" title="在程序的启动时强制更改程序语言设置"></a>在程序的启动时强制更改程序语言设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">     //do something</span><br><span class="line">    //强制设置语言为简体中文</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:@&quot;zh-hans&quot;,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 保存 Device 的现语言 (英语 法语 ，，，)</span><br><span class="line">NSMutableArray *userDefaultLanguages = [[NSUserDefaults standardUserDefaults]</span><br><span class="line">                                        objectForKey:@&quot;AppleLanguages&quot;];</span><br><span class="line"></span><br><span class="line">// 强制 成 简体中文</span><br><span class="line">[[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:@&quot;zh-hans&quot;,nil]</span><br><span class="line">                                              forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">//接下来就是你想要的中文了</span><br><span class="line"></span><br><span class="line">//用完了，转回来， 还原Device 的语言</span><br><span class="line"> [[NSUserDefaults standardUserDefaults] setObject:userDefaultLanguages forKey:@&quot;AppleLanguages&quot;];</span><br></pre></td></tr></table></figure><h1 id="XCode相关"><a href="#XCode相关" class="headerlink" title="XCode相关"></a>XCode相关</h1><ol><li><p>错误描述：</p><p> 虽然勾选了自动管理证书和描述文件，但实际上描述文件被指定为XXXXXX，导致冲突。</p><p> Code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 11.2’<br>这个应该是因为第一个错误产生的，可以不管，把第一个错误fix即可。</p><p> 解决办法：</p><p> 打开项目的project.pbxproj文件，全局搜索XXXXXX，把指定行删除然后保存即可。</p></li><li><p>错误描述：</p><p> <code>Undefined symbols for architecture armv7:</code></p><p> 解决办法：</p><p> 没有满足所有的架构 不支持4S手机<br> 找到  Build Settings 输入 Valid Architectures   删掉armv7  OK。问题解决。</p><blockquote><p>armv7｜armv7s｜arm64都是ARM处理器的指令集<br> armv7｜armv7s｜arm64都是ARM处理器的指令集<br> i386｜x86_64 是Mac处理器的指令集</p></blockquote><blockquote><p>arm64：iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S | iPad Air｜ iPad mini2(iPad mini with Retina Display)</p></blockquote><blockquote><p>armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p></blockquote><blockquote><p>armv7：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p></blockquote><blockquote><p>i386是针对intel通用微处理器32位处理器</p></blockquote><blockquote><p>x86_64是针对x86架构的64位处理器</p></blockquote><blockquote><p>模拟器32位处理器测试需要i386架构，</p></blockquote><blockquote><p>模拟器64位处理器测试需要x86_64架构，</p></blockquote><blockquote><p>真机32位处理器需要armv7,或者armv7s架构，</p></blockquote><blockquote><p>真机64位处理器需要arm64架构。</p></blockquote><blockquote><p>Xcode中指令集相关选项（Build Setting中）</p></blockquote></li></ol><p>Architectures</p><p>指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p><p>Valid Architectures</p><p>限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定</p><p>Build Active Architecture Only</p><p>指定是否只对当前连接设备所支持的指令集编译</p><p>当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdowm&quot;&gt;&lt;a href=&quot;#Markdowm&quot; class=&quot;headerlink&quot; title=&quot;Markdowm&quot;&gt;&lt;/a&gt;Markdowm&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;markdown导出pdf时候强制换页，插入以下代码&lt;/li&gt;
&lt;/ol&gt;
&lt;f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Xcode打包上传AppStore问题</title>
    <link href="https://gongbojie.com/2019/01/25/Xcode%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0AppStore%E9%97%AE%E9%A2%98/"/>
    <id>https://gongbojie.com/2019/01/25/Xcode打包上传AppStore问题/</id>
    <published>2019-01-25T07:24:36.000Z</published>
    <updated>2019-01-25T09:56:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="IMG_01.jpg" alt=""></p><h1 id="1-ERROR-ITMS-90101"><a href="#1-ERROR-ITMS-90101" class="headerlink" title="1. ERROR ITMS-90101"></a>1. ERROR ITMS-90101</h1><p>ERROR ITMS-90101: “This bundle does not support one or more of the devices supported by the previous app version. Your app update must continue to support all devices previously supported. You declare supported devices in Xcode with the Targeted Device Family build setting.</p><p>与之前上传上架的应用的的Deployment Info中的Devices不一致<br>修改为一致即可</p><p><img src="IMG_02.png" alt=""></p><h1 id="2-ERROR-ITMS-90062"><a href="#2-ERROR-ITMS-90062" class="headerlink" title="2. ERROR ITMS-90062"></a>2. ERROR ITMS-90062</h1><p>ERROR ITMS-90062: “This bundle is invalid. The value for key CFBundleShortVersionString [100] in the Info.plist file must contain a higher version than that of the previously approved version [100].”</p><p>原因及解决办法:提交新版本时 CFBundleVersion 和 CFBundleShortVersionString 都要大于上个版本才行<br>它的提示应该是你的 CFBundleShortVersionString 没有大于之前的版本号</p><h1 id="3-ERROR-ITMS-90478"><a href="#3-ERROR-ITMS-90478" class="headerlink" title="3. ERROR ITMS-90478"></a>3. ERROR ITMS-90478</h1><p>同ERROR ITMS-90062构建版本问题</p><h1 id="4-ERROR-ITMS-90023"><a href="#4-ERROR-ITMS-90023" class="headerlink" title="4. ERROR ITMS-90023"></a>4. ERROR ITMS-90023</h1><p>ERROR ITMS-90023: “Missing required icon file”</p><p>缺少iPad或者iPhone的app icon。添加即可。</p><h1 id="5-ERROR-ITMS-90475"><a href="#5-ERROR-ITMS-90475" class="headerlink" title="5. ERROR ITMS-90475"></a>5. ERROR ITMS-90475</h1><p>ERROR ITMS-90475: “Invalid Bundle. iPad Multitasking support requires launch story board in bundle “</p><p>解决方法如下：<br>找到项目下TARGETS-&gt;General-&gt;Deployment Info将Requires full screen打上勾就OK了。</p><p><img src="IMG_03.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;IMG_01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-ERROR-ITMS-90101&quot;&gt;&lt;a href=&quot;#1-ERROR-ITMS-90101&quot; class=&quot;headerlink&quot; title=&quot;1. ERROR ITMS-90101
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>制作framework相关</title>
    <link href="https://gongbojie.com/2018/10/12/%E5%88%B6%E4%BD%9Cframework%E7%9B%B8%E5%85%B3/"/>
    <id>https://gongbojie.com/2018/10/12/制作framework相关/</id>
    <published>2018-10-11T16:12:38.000Z</published>
    <updated>2018-10-12T00:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态库-动态库和framework"><a href="#静态库-动态库和framework" class="headerlink" title="静态库 动态库和framework"></a>静态库 动态库和framework</h1><h2 id="静态库和动态库的区别"><a href="#静态库和动态库的区别" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h2><p>库：一段编译好的二进制代码，加上头文件可供别人使用。程序代码的集合，将N个文件组织起来，是共享程序代码的一种方式。</p><p>使用情景：</p><ol><li>给别人使用，但不希望暴露源码。以库的形式进行封装，只暴露出头文件。。</li><li>某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要Link 一下，不会浪费编译时间。</li></ol><p>上面提到库在使用的时候需要 Link，Link 的方式有两种，静态和动态，于是便产生了静态库和动态库。</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><ul><li>.a</li><li>.framework</li></ul><p>静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。</p><p>静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><ul><li>.dylib</li><li>.framework</li></ul><p>动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。</p><p>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。</p><h2 id="iOS-Framework"><a href="#iOS-Framework" class="headerlink" title="iOS Framework"></a>iOS Framework</h2><p>除了上面提到的 .a 和 .dylib/.tbd 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。</p><p>在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑（见<a href="https://link.jianshu.com/?t=https://stackoverflow.com/questions/4733847/can-you-build-dynamic-libraries-for-ios-and-load-them-at-runtime" target="_blank" rel="noopener">这里的讨论</a>)。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。</p><p>由于上面提到的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如<a href="https://link.jianshu.com/?t=https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">微信的SDK</a>）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。于是人们想出了各种奇技淫巧去让 Xcode Build 出 iOS 可以使用的 Framework，具体做法参考<a href="https://link.jianshu.com/?t=https://github.com/kstenerud/iOS-Universal-Framework" target="_blank" rel="noopener">这里</a>和<a href="https://link.jianshu.com/?t=https://github.com/jverkoey/iOS-Framework" target="_blank" rel="noopener">这里</a>，这种方法产生的 Framework 还有 “伪”(Fake) Framework 和 “真”(Real) Framework 的区别。</p><p>iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以），上面提到的的奇技淫巧也就没有必要了（新的做法参考<a href="https://link.jianshu.com/?t=http://www.cocoachina.com/ios/20141126/10322.html" target="_blank" rel="noopener">这里</a>）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为<a href="https://link.jianshu.com/?t=https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html" target="_blank" rel="noopener">Embedded Framework</a>。</p><h2 id="静态库和动态库的区别-1"><a href="#静态库和动态库的区别-1" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h2><ul><li>.a文件肯定是静态库，.dylib肯定是动态库，.framework可能是静态库也可能是动态库；</li><li>静态库在链接时，会被完整的复制到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是浪费内存。类似于定义一个基本变量，使用该基本变量是是新复制了一份数据，而不是原来定义的；</li><li>动态库不会复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存。类似于使用变量的内存地址一样，使用的是同一个变量；</li><li>但是项目中如果使用了自己定义的动态库，苹果是不允许上架的，在iOS8.0以后苹果开放了动态加载.dylib的接口，用于挂载.dylib动态库</li></ul><h2 id="Swift-支持"><a href="#Swift-支持" class="headerlink" title="Swift 支持"></a>Swift 支持</h2><p>跟着 iOS8 / Xcode 6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种，一种是把代码拷贝到工程中，另一种是用动态 Framework。使用静态库是不支持的。</p><p>造成这个问题的原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的运行库（这是<a href="https://link.jianshu.com/?t=https://github.com/ksm/SwiftInFlux#static-libraries" target="_blank" rel="noopener">苹果自家的解释</a>）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了（参考<a href="https://link.jianshu.com/?t=https://stackoverflow.com/questions/25020783/how-to-distribute-swift-library-without-exposing-the-source-code" target="_blank" rel="noopener">这个问题</a>的问题描述，也是来自苹果自家文档）。</p><h2 id="CocoaPods-的做法"><a href="#CocoaPods-的做法" class="headerlink" title="CocoaPods 的做法"></a>CocoaPods 的做法</h2><p>在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考<a href="https://link.jianshu.com/?t=http://www.cnblogs.com/brycezhang/p/4117180.html" target="_blank" rel="noopener">这里</a>，或者使用<a href="https://link.jianshu.com/?t=https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">CocoasPods-Packager</a>这个插件。</p><p>当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了vendored_framework选项来使用第三方 Framework，具体的做法可以参考<a href="https://link.jianshu.com/?t=http://www.telerik.com/blogs/how-to-use-a-third-party-framework-in-a-private-cocoapod" target="_blank" rel="noopener">这里</a>和<a href="https://link.jianshu.com/?t=https://stackoverflow.com/questions/18219286/podspec-link-binary-library" target="_blank" rel="noopener">这里</a>。</p><p>对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持，通过use_frameworks!选项控制。</p><h1 id="制作静态库-framework"><a href="#制作静态库-framework" class="headerlink" title="制作静态库 .framework"></a>制作静态库 .framework</h1><ol><li>创建静态库工程，默认是动态库，修改Build Settings—&gt;Mach-O Type:Static Library<img src="http://jbcdn2.b0.upaiyun.com/2016/10/c1e36447ea240df6fa3685e47cc0223b.png" alt=""> <img src="http://jbcdn2.b0.upaiyun.com/2016/10/5aeb92b929c0f3e050d51c87d56feac2.png" alt=""></li><li>创建一个类，模拟静态库中的一个功能 <img src="http://jbcdn2.b0.upaiyun.com/2016/10/bbdfb691df44a73d580f23011693f5d4.png" alt=""></li><li>公开头文件<img src="http://jbcdn2.b0.upaiyun.com/2016/10/8603495f2a29e641ee133fac4fccc279.png" alt=""><img src="http://jbcdn2.b0.upaiyun.com/2016/10/ee31689627204143efb6a83292cad622.png" alt=""></li><li>将其他需要公开的头文件包含到总的头文件中<img src="http://jbcdn2.b0.upaiyun.com/2016/10/c7f83b729e98dffcd511b93993156aa8.png" alt="">iFly.h 是一个总的头文件，可以将其他需要公开的文件都统一写到总的头文件中，用户在使用的时候就导入这一个总的头文件即可</li><li>修改Build Settings–&gt;Build Active Architecture Only: NO, 将Scheme修改为Release 分别选择真机和模拟器进行编译 Command + B, 右键iFly.framework Show In Finder<img src="http://jbcdn2.b0.upaiyun.com/2016/10/bd6050b95476709335f4ea0f6b2a34b1.png" alt=""><img src="http://jbcdn2.b0.upaiyun.com/2016/10/bfa655554b0d7ae13ca084088f5271c8.png" alt=""></li><li>查看Release版本的模拟器和真机支持的架构<img src="http://jbcdn2.b0.upaiyun.com/2016/10/03d5bb2998dfe265ea6d40abb379c8b2.png" alt=""></li><li>创建一个项目进行测试，将Release-iphonesimulator下的iFly.framework拖进到工程中，并调用静态库中的方法<img src="http://jbcdn2.b0.upaiyun.com/2016/10/07c383ac95222ec157d6e0ce84d833c2.png" alt=""></li></ol><hr><p>PS：<br>参考：<a href="https://www.jianshu.com/p/ee2affaa3bac" target="_blank" rel="noopener">静态库，动态库与 Framework</a><br><a href="http://ios.jobbole.com/89871/" target="_blank" rel="noopener">iOS 静态库和动态库的基本介绍和使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态库-动态库和framework&quot;&gt;&lt;a href=&quot;#静态库-动态库和framework&quot; class=&quot;headerlink&quot; title=&quot;静态库 动态库和framework&quot;&gt;&lt;/a&gt;静态库 动态库和framework&lt;/h1&gt;&lt;h2 id=&quot;静态库和动
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Xcode打包提交第三方包出错问题</title>
    <link href="https://gongbojie.com/2018/08/27/Xcode%E6%89%93%E5%8C%85%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>https://gongbojie.com/2018/08/27/Xcode打包提交第三方包出错问题/</id>
    <published>2018-08-27T09:43:11.000Z</published>
    <updated>2018-08-27T10:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/880fe8a4gy1fuoc0p6djaj20f705iq4a.jpg" alt=""></p><ol><li>第三方框架的plist文件，查看plist文件中，找出key是CFBundleExecutable(或者是Executable file)的配置行。一般都是在某些第三方的plist文件中。</li></ol><p><img src="http://ww1.sinaimg.cn/large/880fe8a4gy1fuoc29g7i4j20yi0q8q9a.jpg" alt=""></p><ol start="2"><li>将找出所有第三方plist文件中的CFBundleExecutable行，CFBundleSupportedPlatforms行删除</li><li>重新打包，提交</li></ol><p><a href="https://stackoverflow.com/questions/32622899/itms-90535-unable-to-publish-ios-app-with-latest-google-signin-sdk" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/880fe8a4gy1fuoc0p6djaj20f705iq4a.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第三方框架的plist文件，查看plist文件中，找出key是CFBundleE
      
    
    </summary>
    
    
      <category term="Xcode, App Store" scheme="https://gongbojie.com/tags/Xcode-App-Store/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目在SVN和Git中应该忽略的文件</title>
    <link href="https://gongbojie.com/2018/08/10/iOS%E9%A1%B9%E7%9B%AE%E5%9C%A8SVN%E5%92%8CGit%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>https://gongbojie.com/2018/08/10/iOS项目在SVN和Git中应该忽略的文件/</id>
    <published>2018-08-10T12:26:30.000Z</published>
    <updated>2020-09-04T09:10:42.137Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，有些文件应该忽略，操作不当，有时候在Xcode项目中打了一个断点，就提示文件修改需要提交。下面就是我们需要注意的问题</p><a id="more"></a><hr><h1 id="2020-09-04-更新"><a href="#2020-09-04-更新" class="headerlink" title="2020/09/04 更新"></a>2020/09/04 更新</h1><p>Podfile.lock文件需要上传git仓库</p><p>先上Cocoapods官方说明：</p><blockquote><p>Commit your Podfile.lock As a reminder, even if your policy is not to commit the Pods folder into your shared repository, you should always commit &amp; push your Podfile.lock file.<br>Otherwise, it would break the whole logic explained above about pod install being able to lock the installed versions of your pods. </p></blockquote><p>从官方引导中，我们可以肯定的说podfile.lock一定要加到版本控制上传到git，而不是添加到gitignore。从而防止第三方库升级造成不同开发人员之间版本不同。</p><p>pod install遵循 先按pod file.lock来， 如果podfile.lock里面没有该库，再按pod file进行下载。 pod update 不管pod file.lock的repos版本， 而是直接在符合podfile里面版本要求的前提下，更新到最新库，如果podfile没有该repo版本要求，则直接更新到最新。</p><p>因此要尽量先pod install，而不是pod update pod update会更新到最新的库，尤其是对于那些未指定的版本的repo，如果这样做了，有时候会很麻烦，因为项目是基于专门的稳定版本进行开发的，而pod update 后，最新版本改了很多东西</p><p>如果podfile中某个库的版本控制修改了，则可以通过 pod update modifiedRepoName进行更新。</p><p><a href="https://www.dazhuanlan.com/2019/10/16/5da66ddfe362d/" target="_blank" rel="noopener">引用文章链接</a></p><hr><p>###.DS_Store</p><p>添加忽略</p><h3 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h3><p>Pods 这个目录可以不提交，甚至 Podfile.lock 这个文件也可以不要，继而 .xcworkspace也可以不要，只要留一个Podfile文件，并在里面指定每个依赖库的版本号就够了，只要团队的每个人都有 CocoaPods 环境，每个人 pod install 后，在本地就能跑起来了。</p><h3 id="xcuserdata"><a href="#xcuserdata" class="headerlink" title="xcuserdata"></a>xcuserdata</h3><p>在项目根目录下，一般有 .xcodeproj 和 .xcworkspace文件，显示包内容可以看到都有 xcuserdata 文件夹，然后里面放着 username.xcuserdata文件夹，再点进去就是 UserInterfaceState.xcuserstate 和 Breakpoints_v2.xcbkptlist，这些都属于用户个人设置，像断点记录这样的文件肯定不能提交上去合并的，没有意义，也容易导致冲突。</p><h3 id="fastlane"><a href="#fastlane" class="headerlink" title="fastlane"></a>fastlane</h3><p>fastlane/report.xml<br>fastlane/Preview.html<br>fastlane/screenshots<br>fastlane/test_output</p><p>综上 简单配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Xcode</span><br><span class="line">.DS_Store</span><br><span class="line">build</span><br><span class="line">report.xml</span><br><span class="line">*.pbxuser</span><br><span class="line">!<span class="keyword">default</span>.pbxuser</span><br><span class="line">*.mode1v3</span><br><span class="line">!<span class="keyword">default</span>.mode1v3</span><br><span class="line">*.mode2v3</span><br><span class="line">!<span class="keyword">default</span>.mode2v3</span><br><span class="line">*.perspectivev3</span><br><span class="line">!<span class="keyword">default</span>.perspectivev3</span><br><span class="line">xcuserdata</span><br><span class="line">*.moved-aside</span><br><span class="line">DerivedData</span><br><span class="line">.idea</span><br><span class="line">*.hmap</span><br><span class="line">*.xccheckout</span><br><span class="line">*.xcworkspace</span><br><span class="line">!<span class="keyword">default</span>.xcworkspace</span><br><span class="line"></span><br><span class="line">#CocoaPods</span><br><span class="line">Pods</span><br><span class="line">#Podfile.lock</span><br><span class="line">xcschemes</span><br><span class="line"></span><br><span class="line"><span class="meta"># fastlane</span></span><br><span class="line">fastlane/report.xml</span><br><span class="line">fastlane/Preview.html</span><br><span class="line">fastlane/screenshots</span><br><span class="line">fastlane/test_output</span><br></pre></td></tr></table></figure><h3 id="或者gitignore-io-选择自定义配置"><a href="#或者gitignore-io-选择自定义配置" class="headerlink" title="或者gitignore.io 选择自定义配置"></a>或者gitignore.io 选择自定义配置</h3><p>在<a href="https://www.gitignore.io/" target="_blank" rel="noopener">gitignore.io</a> 输入需要配置的语言，会自动生成一份配置。比如，输入 Objective-C 和 Swift 会帮助你生成下面的配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"># Created by https:<span class="comment">//www.gitignore.io/api/swift,objective-c</span></span><br><span class="line">### Objective-C ###</span><br><span class="line"># Xcode</span><br><span class="line">#</span><br><span class="line"><span class="meta"># gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore</span></span><br><span class="line">## Build generated</span><br><span class="line">build/</span><br><span class="line">DerivedData/</span><br><span class="line">## Various settings</span><br><span class="line">*.pbxuser</span><br><span class="line">!<span class="keyword">default</span>.pbxuser</span><br><span class="line">*.mode1v3</span><br><span class="line">!<span class="keyword">default</span>.mode1v3</span><br><span class="line">*.mode2v3</span><br><span class="line">!<span class="keyword">default</span>.mode2v3</span><br><span class="line">*.perspectivev3</span><br><span class="line">!<span class="keyword">default</span>.perspectivev3</span><br><span class="line">xcuserdata/</span><br><span class="line">## Other</span><br><span class="line">*.moved-aside</span><br><span class="line">*.xccheckout</span><br><span class="line">*.xcscmblueprint</span><br><span class="line">## Obj-C/Swift specific</span><br><span class="line">*.hmap</span><br><span class="line">*.ipa</span><br><span class="line">*.dSYM.zip</span><br><span class="line">*.dSYM</span><br><span class="line"># CocoaPods</span><br><span class="line">#</span><br><span class="line"># We recommend against adding the Pods directory to your .gitignore. However</span><br><span class="line"><span class="meta"># you should judge for yourself, the pros and cons are mentioned at:</span></span><br><span class="line"><span class="meta"># https:<span class="comment">//guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control</span></span></span><br><span class="line">#</span><br><span class="line"># Pods/</span><br><span class="line"># Carthage</span><br><span class="line">#</span><br><span class="line"># Add <span class="keyword">this</span> line <span class="keyword">if</span> you want to avoid checking in source code from Carthage dependencies.</span><br><span class="line"># Carthage/Checkouts</span><br><span class="line">Carthage/Build</span><br><span class="line"><span class="meta"># fastlane</span></span><br><span class="line">#</span><br><span class="line"># It is recommended to <span class="keyword">not</span> store the screenshots in the git repo. Instead, use fastlane to re-generate the</span><br><span class="line"><span class="meta"># screenshots whenever they are needed.</span></span><br><span class="line"># For more information about the recommended setup visit:</span><br><span class="line"><span class="meta"># https:<span class="comment">//docs.fastlane.tools/best-practices/source-control/#source-control</span></span></span><br><span class="line">fastlane/report.xml</span><br><span class="line">fastlane/Preview.html</span><br><span class="line">fastlane/screenshots</span><br><span class="line">fastlane/test_output</span><br><span class="line"># Code Injection</span><br><span class="line">#</span><br><span class="line"># After <span class="keyword">new</span> code Injection tools there's a generated folder /iOSInjectionProject</span><br><span class="line"># https:<span class="comment">//github.com/johnno1962/injectionforxcode</span></span><br><span class="line">iOSInjectionProject/</span><br><span class="line">### Objective-C Patch ###</span><br><span class="line">### Swift ###</span><br><span class="line"># Xcode</span><br><span class="line">#</span><br><span class="line"># gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore</span><br><span class="line">## Build generated</span><br><span class="line">## Various settings</span><br><span class="line">## Other</span><br><span class="line">## Obj-C/Swift specific</span><br><span class="line">## Playgrounds</span><br><span class="line">timeline.xctimeline</span><br><span class="line">playground.xcworkspace</span><br><span class="line"># Swift Package Manager</span><br><span class="line">#</span><br><span class="line"># Add <span class="keyword">this</span> line <span class="keyword">if</span> you want to avoid checking in source code from Swift Package Manager dependencies.</span><br><span class="line"># Packages/</span><br><span class="line"># Package.pins</span><br><span class="line">.build/</span><br><span class="line"># CocoaPods</span><br><span class="line">#</span><br><span class="line"># We recommend against adding the Pods directory to your .gitignore. However</span><br><span class="line"># you should judge <span class="keyword">for</span> yourself, the pros <span class="keyword">and</span> cons are mentioned at:</span><br><span class="line"># https:<span class="comment">//guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control</span></span><br><span class="line">#</span><br><span class="line"># Pods/</span><br><span class="line"># Carthage</span><br><span class="line">#</span><br><span class="line"># Add <span class="keyword">this</span> line <span class="keyword">if</span> you want to avoid checking in source code from Carthage dependencies.</span><br><span class="line"># Carthage/Checkouts</span><br><span class="line"># fastlane</span><br><span class="line">#</span><br><span class="line"># It is recommended to <span class="keyword">not</span> store the screenshots in the git repo. Instead, use fastlane to re-generate the</span><br><span class="line"># screenshots whenever they are needed.</span><br><span class="line"># For more information about the recommended setup visit:</span><br><span class="line"># https:<span class="comment">//docs.fastlane.tools/best-practices/source-control/#source-control</span></span><br><span class="line"># End of https:<span class="comment">//www.gitignore.io/api/swift,objective-c</span></span><br></pre></td></tr></table></figure><p>使用SVN的cornerstone是在设置中添加忽略<br><img src="http://ww1.sinaimg.cn/large/880fe8a4gy1fu4w9qd4ujj20zo0zytlp.jpg" alt=""><br>使用Git的话，直接写入.gitignore文件即可</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>.gitignore 可以忽略没必要提交的文件和目录，极大地减轻冲突几率，也可以让远程仓库更小一些。项目一开始就配置好 .gitignore，只留一个 Podfile 即可。如果项目进行到一半，添加完 .gitignore 后，需要删除追踪文件并重新提交。</p><p>PS：使用Cornerstone的话，已经添加到服务器的文件是不能选择忽略的。在第一次提交到服务器的时候就需要做好忽略的。</p><p>参考文章： <a href="https://bingozb.github.io/37.html" target="_blank" rel="noopener">https://bingozb.github.io/37.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，有些文件应该忽略，操作不当，有时候在Xcode项目中打了一个断点，就提示文件修改需要提交。下面就是我们需要注意的问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="Xcode, Git, SVN" scheme="https://gongbojie.com/tags/Xcode-Git-SVN/"/>
    
  </entry>
  
  <entry>
    <title>OSX High Sierra 10.13 装cocoapods踩坑</title>
    <link href="https://gongbojie.com/2018/07/28/OSX-High-Sierra-10-13-%E8%A3%85cocoapods%E8%B8%A9%E5%9D%91/"/>
    <id>https://gongbojie.com/2018/07/28/OSX-High-Sierra-10-13-装cocoapods踩坑/</id>
    <published>2018-07-28T09:35:02.000Z</published>
    <updated>2018-09-26T07:51:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关掉SIP"><a href="#关掉SIP" class="headerlink" title="关掉SIP"></a>关掉SIP</h2><p>步骤：</p><ol><li>进入Recovery Mode模式: 重启Mac，按住Command + R键直到Apple Logo出现 </li><li>关闭SIP：点击工具里的Terminal（终端），输入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil disable</span><br></pre></td></tr></table></figure><ol start="4"><li>重启Mac，重启完成后，终端中输入 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chflags norestricted /usr/local &amp;&amp; sudo chown -R $(whoami):admin /usr/local</span><br></pre></td></tr></table></figure><p>关闭SIP完毕</p><p>PS:（如果想重新开启安全设置，则重复1、2步骤，输入csrutil enable就可以了）</p><p>原因：10.13版本加强了权限的限制，尤其是对/usr/local目录，默认开通 SIP （System Intergrity Protection），它禁止了软件以root身份在Mac上运行，不管你是在终端中如何运行。</p><a id="more"></a><h2 id="换源："><a href="#换源：" class="headerlink" title="换源："></a>换源：</h2><p>请尽可能用比较新的 RubyGems 版本，建议 2.6.x 以上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gem update --system # 这里请翻墙一下</span><br><span class="line">$ gem -v</span><br><span class="line">2.6.3</span><br></pre></td></tr></table></figure></p><p>更换源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources -l</span><br><span class="line">https://gems.ruby-china.com</span><br><span class="line"># 确保只有 gems.ruby-china.com</span><br></pre></td></tr></table></figure><h2 id="部署cocoapods"><a href="#部署cocoapods" class="headerlink" title="部署cocoapods"></a>部署cocoapods</h2><p>在cocoapods慢到吐血的情况下 选择国内镜像吧 </p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/CocoaPods/" target="_blank" rel="noopener">清华大学镜像站</a></p><p>新版的 CocoaPods 不允许用pod repo add直接添加master库了，使用以下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.cocoapods/repos </span><br><span class="line">$ pod repo remove master</span><br><span class="line">$ git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master</span><br></pre></td></tr></table></figure><p>最后进入自己的工程，在自己工程的podFile第一行加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关掉SIP&quot;&gt;&lt;a href=&quot;#关掉SIP&quot; class=&quot;headerlink&quot; title=&quot;关掉SIP&quot;&gt;&lt;/a&gt;关掉SIP&lt;/h2&gt;&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入Recovery Mode模式: 重启Mac，按住Command + R键直到Apple Logo出现 &lt;/li&gt;
&lt;li&gt;关闭SIP：点击工具里的Terminal（终端），输入&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;csrutil disable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;重启Mac，重启完成后，终端中输入 &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo chflags norestricted /usr/local &amp;amp;&amp;amp; sudo chown -R $(whoami):admin /usr/local&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关闭SIP完毕&lt;/p&gt;
&lt;p&gt;PS:（如果想重新开启安全设置，则重复1、2步骤，输入csrutil enable就可以了）&lt;/p&gt;
&lt;p&gt;原因：10.13版本加强了权限的限制，尤其是对/usr/local目录，默认开通 SIP （System Intergrity Protection），它禁止了软件以root身份在Mac上运行，不管你是在终端中如何运行。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由AFN的url encode请求引发的问题</title>
    <link href="https://gongbojie.com/2018/07/19/AFN%E7%9A%84urlencode%E8%AF%B7%E6%B1%82/"/>
    <id>https://gongbojie.com/2018/07/19/AFN的urlencode请求/</id>
    <published>2018-07-19T06:42:27.000Z</published>
    <updated>2018-08-11T02:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中的网络请求大多数情况下使json格式返回，但是有时候也有其他的格式。</p><h2 id="Postman中使用url-encode"><a href="#Postman中使用url-encode" class="headerlink" title=" Postman中使用url encode"></a><i class="fab fa-internet-explorer"></i> Postman中使用url encode</h2><p><img src="http://ww1.sinaimg.cn/large/880fe8a4gy1ftfaqhy4ndj20uk092q49.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/880fe8a4gy1ftfano5tswj20uk0aj3zt.jpg" alt=""></p><a id="more"></a><h2 id="AFN常规请求"><a href="#AFN常规请求" class="headerlink" title="AFN常规请求"></a>AFN常规请求</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">    manager.requestSerializer=[AFJSONRequestSerializer serializer];<span class="comment">//申明请求的数据是json类型</span></span><br><span class="line">    manager.responseSerializer = [AFJSONResponseSerializer serializer];<span class="comment">//申明返回的结果是json类型</span></span><br><span class="line">    [manager POST:hostUrl parameters:dic success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"success--%@--%@"</span>,[responseObject <span class="keyword">class</span>],responseObject);</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failure--%@"</span>,error);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>发现返回结果报错</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">failure--Error Domain=com.alamofire.error.serialization.response Code=-1011 "Request failed: unsupported media type (415)" </span><br><span class="line">UserInfo=&#123;NSLocalizedDescription=Request failed: unsupported media type (415), NSUnderlyingError=0x1c0646930 </span><br><span class="line">&#123;Error Domain=com.alamofire.error.serialization.response Code=-1016 "Request failed: unacceptable content-type: text/html" </span><br><span class="line">UserInfo=&#123;NSLocalizedDescription=Request failed: unacceptable content-type: text/html, NSErrorFailingURLKey=http:</span><br><span class="line"></span><br><span class="line">Headers &#123;</span><br><span class="line">    Content-Type = (</span><br><span class="line">    text/html;charset=utf-8,</span><br><span class="line">);</span><br><span class="line">    Content-Length = (</span><br><span class="line">    1092,</span><br><span class="line">);</span><br><span class="line">    Server = (</span><br><span class="line">    Apache-Coyote/1.1,</span><br><span class="line">);</span><br><span class="line">    Date = (</span><br><span class="line">    Thu, 19 Jul 2018 09:43:07 GMT,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意到code=-1011，错误码为415，text/html;charset=utf-8</p><p>接着加上请求的编码格式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">后经验证 这一行设置代码可以删除 使用 manager.requestSerializer = [AFHTTPRequestSerializer serializer]; 即可</span><br><span class="line"></span><br><span class="line">[manager.requestSerializer setValue:<span class="string">@"application/x-www-form-urlencoded;"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br></pre></td></tr></table></figure><p>发现时json编码格式，不对<br>接着查看AFN的请求Header，加上以下代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSHTTPURLResponse</span> *response = (<span class="built_in">NSHTTPURLResponse</span> *)task.response;</span><br><span class="line"><span class="built_in">NSDictionary</span> *allHeaders = response.allHeaderFields;</span><br></pre></td></tr></table></figure><p>allHeaders中的数据<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Content-Type = application/json;</span><br><span class="line">    Content-Length = 63;</span><br><span class="line">    Server = Apache-Coyote/1.1;</span><br><span class="line">    Date = Thu, 19 Jul 2018 09:49:12 GMT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以进行到请求成功里面，但是返回的POST的提交的数据却无法提交，返回结果为提交的数据为空，表示提交的数据编码不对，修改请求的编码序列化<br><del>manager.requestSerializer = [AFJSONRequestSerializer serializer];</del></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br></pre></td></tr></table></figure><p>然后可以正常进行数据请求了。</p><hr><p>参考文章：</p><ol><li><a href="https://www.jianshu.com/p/81e648ac3589" target="_blank" rel="noopener">AFNetworking报错:(415 Domain=com.alamofire.error.serialization.response Code=-1011 “Request failed: unsupported media type (415)”)</a></li><li><a href="https://www.jianshu.com/p/2580c05d5a1d" target="_blank" rel="noopener">AFN Post请求中出现的问题</a></li><li><a href="https://juejin.im/post/5a71289c5188252edb592f5f" target="_blank" rel="noopener">AFNetworking之AFURLRequestSerialization深入学习</a></li><li><a href="https://juejin.im/entry/58f850eb0ce4630061105c8d" target="_blank" rel="noopener">AFNetWorking 源码分析之 AFHTTPSessionManager</a></li><li><a href="https://www.jianshu.com/p/a9f09052eaed" target="_blank" rel="noopener">使用 AFNetworking3.0请求时如何获取响应头文件</a></li><li><a href="https://www.jianshu.com/p/22075e7db6f7" target="_blank" rel="noopener">AFNetworking源码解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中的网络请求大多数情况下使json格式返回，但是有时候也有其他的格式。&lt;/p&gt;
&lt;h2 id=&quot;Postman中使用url-encode&quot;&gt;&lt;a href=&quot;#Postman中使用url-encode&quot; class=&quot;headerlink&quot; title=&quot; Postman中使用url encode&quot;&gt;&lt;/a&gt;&lt;i class=&quot;fab fa-internet-explorer&quot;&gt;&lt;/i&gt; Postman中使用url encode&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/880fe8a4gy1ftfaqhy4ndj20uk092q49.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/880fe8a4gy1ftfano5tswj20uk0aj3zt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
